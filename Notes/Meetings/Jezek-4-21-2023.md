- Napsal jsem cast proposalu k zavedeni `_`
  - Motivace
  - Scope
    - Prvni cast stacilo lehce upravit dokumentaci
- Ted zkoumam jak udelat inference `new List<_>{1,2,3}`
- Cerpam z prikladu Rust, Haskell and ML viz. clanek
- Prijde mi slibne H-M type inference -> ikdyz s dedicnosti, overloadingem je nerozhodnutelna
- Libilo by se mi vydat cestou kterou zvolil rust, ackoliv dokuentace neni moc podrobna a code base je rozsahla
- V podstate mam Ctx, ktery si udruzuje type promennych (typy muzou obsahovat i typove prommene)
  - jak prochazim kodem, pridavam contrainy na typove promenne, a tim je vice a vice specifikuji
  - Na konci zkontroluji, zde typova promena zkolabovala do typu
- nechtelo se mi to davat do Roslynu jelikoz codebase je velka
- Udelal jsem si demo, ale pak jsem prisel na to ze neobsahuje vsechny konstruty, co bych potreboval doresit
- Nyni jsem po nekolikate prosel type inferenci v roslynu a prijde mi, ze je to vysek z H-M type inference
  - Je to omezene pouze na volani metody(vsechny typy parametru, ktere se ucastni boundingu musi byt predem zname) + target_typed new, switch condition,array initializace
  - Vesledkem je substituce neobsahujici jine typove promenne -> takze nemuzu ohranicit zvenci
  - U H-M toto omezeni nemame, a muzeme ohranicit typovou promennou jinou.
  - Pokud bych chtel delat zmeny, tohle by potreboval zrelaxovat.

Jak by slo vyresit `List<_>{1,2,3}`
-> pustit inferenci na `Add` metody -> dovolit vratit typove prommene
-> pote resolvnout contrainy techto prommenych

```csharp
Add (Foo<T1, T2> a)...
Add(Foo2<T3> a)....
....
```

Jak funguje Roslyn
1. Syntax abstract tree -> u ktereho nema propojene reference na jmena
2. Nejdrive se kompiluji deklerace, potom tela metod.
3. Binding faze(Bez nullable) -> Prochazi visitorem SAT a tvori hiearchii Binderu(obsahuje jmena entitit, co se vyskytuje v jeho prostredi -> NamespaceBinder, ClassBinder, MethodBinder)
   1. kdyz pak hledam jmeno neceho, prochazim nahoru tuto hiearchii
4. Pokud narazim na (generickou)metodu
   1. Method lookup(overloads) -> pro kazdy pripad vyvolam typeinferenci metody
   2. stricim do overload resolution
   3. pokud byla uspesna, substituji nalezeny typy do argumentu metody
5. Binding faze(S nullable) -> to same, ale uvazuje nullable

```
using System;
using System.Collections;

public class C {
    public void M() {
        // OK
        Foo<int, int, int, A> t1 = new Foo<int, int, int, A>(1){1, new Bar<int, int>(), new Baz<int>(), new B()};
        // transformed into
        // OK
        Foo<int, int, int, A> t2 = Helper_Foo.newFoo<int, int, int, A>(1);
        Helper_Foo.Add(t2, 1);
        Helper_Foo.Add(t2, new Bar<int, int>());
        Helper_Foo.Add(t2, new Baz<int>());
        Helper_Foo.Add(t2, new B());
        // with `_`
        // Fail
        // new Foo<_, _, _, _>(1){1, new Bar<int, int>(), new Baz<int>(), new B()};
        Foo<_, _, _, A> t3 = Helper_Foo.newFoo<_, _, _, _>(1); // Save context -> -> T4 :> A
        Helper_Foo.Add<_, _, _, _>(t3, 1); // Save context -> T1 = int
        Helper_Foo.Add<_, _, _, _>(t3, new Bar<int, int>()); // Save context -> T1 = int, T2 = int
        Helper_Foo.Add<_, _, _, _>(t3, new Baz<int>()); // Save context -> T3 = int
        Helper_Foo.Add<_, _, _, _>(t3, new B()); // Save context -> T4 = B
        // Combine type parameters -> <int,int, int, B>
        // -> new Foo<int, int, int, A>(1){1, new Bar<int, int>(), new Baz<int>(), new B()};
    }
}

public class A {}
public class B : A {}

public class Bar<T1, T2> {}

public class Baz<T1> : Bar<T1, string> {}

public class Foo<T1, T2, T3, T4> : IEnumerable {
    public IEnumerator GetEnumerator() => throw new NotImplementedException();
    
    public Foo(int p1) {}
    public Foo(int p1, string p2) {}
    public Foo(string p1, float p2) {}
    
    public void Add(T1 p1) {}
    public void Add(Bar<T1,T2> p1) {}
    public void Add(Bar<T3, string> p1) {}
    public void Add(T4 p1) {}
}

// Transformed into

public static class Helper_Foo{
    // construtor
    public static Foo<T1, T2, T3, T4> newFoo<T1, T2, T3, T4>(int p1) => throw new NotImplementedException();
    public static Foo<T1, T2, T3, T4> newFoo<T1, T2, T3, T4>(int p1, string p2) => throw new NotImplementedException();
    public static Foo<T1, T2, T3, T4> newFoo<T1, T2, T3, T4>(string p1, float p2) => throw new NotImplementedException();
    //Add
    public static void Add<T1,T2,T3,T4>(Foo<T1,T2,T3,T4> @this, T1 p1) => throw new NotImplementedException();
    public static void Add<T1,T2,T3,T4>(Foo<T1,T2,T3,T4> @this, Bar<T1,T2> p1) => throw new NotImplementedException();
    public static void Add<T1,T2,T3,T4>(Foo<T1,T2,T3,T4> @this, Bar<T3, string> p1) => throw new NotImplementedException();
    public static void Add<T1,T2,T3,T4>(Foo<T1,T2,T3,T4> @this, T4 p1) => throw new NotImplementedException();
}
```

Zaver