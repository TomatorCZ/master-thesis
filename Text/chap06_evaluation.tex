\chapter{Evaluation}

The implementation and proposal are evaluated using the following metrics.

\section{Tests}

We run the same suite case before and after our changes. 
The results can be found in the \texttt{/Attachments/TestResults} folder containing the \texttt{Test-Master} folder and the \texttt{Test-Feature} folder corresponding to test results before and after the change. 
These folders contain the results from the \texttt{-testCompilerOnly} suite case run whose tests can be found the the \texttt{Test} folder mentioned in Section \ref{roslynRepo:overview}.
All tests pass when they are run separately.
However, we noticed that when we use the testing framework to run \texttt{-testCompilerOnly} suite case, two of our tests don't pass as can be seen in the \texttt{WorkItem\_4\_x64\_test\_results.html} test results summary.
We didn't manage to identify the reason for that, but we believe that it is related to the test framework complexity of how it runs the tests.
This failure needs further investigation in the context of how the test framework executes the tests.
Except for this failure and unimportant small changes in the compiler tests regarding adding new error messages caused by our changes, all tests that passed before the improvement also passed after the improvement.
This result ensures that the improvement doesn’t introduce any significant regression in the compiler tests.

\section{Demo Examples}

The basic capabilities of the improvement are demonstrated in the demo application contained in the \texttt{Attachments/Demo} attachments folder. 
We also show advanced features of the improvement which can be found in the tests and which were presented to LDT. 


\subsection{Basics}

Figure \ref{img100:example1} shows an example of the partial method type inference where the underscore is used to skip the first type argument of the \texttt{M1} method call because it can be inferred from the first argument.
In this case, the inferred type argument is \texttt{int}.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
void M1<T1, T2>(T1 p1) { ... }
...
M1<_, string>(1);
\end{lstlisting}
\caption{RunExample1 -- Top level inferred type argument}
\label{img100:example1}
\end{figure}
\par
Figure \ref{img101:example2} shows the usage of the underscore in the first type argument of the \texttt{M2} method call where it is an inferred type argument of the \texttt{IList<T>} type.
The usage allows to influence the original method type inference algorithm which would infer the type of the first argument.
The nested inferred type argument is \texttt{int}.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
void M2<T1>(T1 p1) { ... }
...
M2<IList<_>>(new List<int>());
\end{lstlisting}
\caption{RunExample2 -- Nested inferred type argument}
\label{img101:example2}
\end{figure}
\par
Figure \ref{img102:example3} shows an example of the partial constructor type inference where the first type argument of the \texttt{C1<T1>} object creation expression is inferred based on the first argument.
The process of the type inference is the same as in the first example.
The inferred type argument is \texttt{int}.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C1<T1> {
  public C1(T1 p1) { ... }
}
...
new C1<_>(1);
\end{lstlisting}
\caption{RunExample3 -- Top level inferred type argument}
\label{img102:example3}
\end{figure}
\par
Figure \ref{img103:example4} shows the usage of the nested inferred type in the \texttt{C2<T1>} object creation expression.
The process of type inference is the same as in the second example.
The nested inferred type argument is \texttt{int}.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C2<T1> {
  public C2(T1 p1) { ... }
}
...
new C2<IList<_>>(new List<int>());
\end{lstlisting}
\caption{RunExample4 -- Nested inferred type argument}
\label{img103:example4}
\end{figure}
\par
Figure \ref{img104:example5} shows an example where type inference of the \texttt{C3<T1>} object creation expression uses the target type to infer the type argument of the \texttt{C3<T1>} type.
The target type is the \texttt{C3<int>} type obtained from the \texttt{a} variable declaration.
The inferred type argument is the \texttt{int} type.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C3<T1> {
  public C3() { ... }
}
...
C3<int> a = new C3<_>();
\end{lstlisting}
\caption{RunExample5 -- Target-typed inference}
\label{img104:example5}
\end{figure}
\par
Figure \ref{img105:example6} shows an example of type inference based on the type constraints where the first type argument of the \texttt{C4<T1, T2>} object creation expression is inferred based on the second type argument.
Since the first type argument has to inherit the \texttt{List<T2>} type, it gives us a default for this type argument.
So the first type argument is inferred to the \texttt{List<int>} type. 
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C4<T1, T2> where T1 : List<T2> {
    public C4() { ... }
}
    
new C4<_, int>();
\end{lstlisting}
\caption{RunExample6 -- Type inference based on constraints}
\label{img105:example6}
\end{figure}

\newpage

\subsection{Advanced Examples}

Figure \ref{img73:example1} shows the \texttt{F4} generic method containing three function parameters. 
The parameters and arguments are assembled in the way that is required to infer \texttt{T1} to infer \texttt{T2}, which is required to infer \texttt{T3}, which is required to infer \texttt{T1}. 
The call site uses the partial method type inference to hint to the compiler one of the type arguments, which will break this circular dependency and enable the inference of the rest of the type parameters.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
void F4<T1, T2, T3>(
  Func<T1, T2> p12, 
  Func<T2, T3> p23, 
  Func<T3, T1> p31) 
{}
...
F4<_, _, string>(x => x + 1, y => y.ToString(), z => z.Length); 
\end{lstlisting}
\caption{Circular type inference dependency of type parameters}
\label{img73:example1}
\end{figure}
\par
Figure \ref{img74:example2} shows an advanced scenario containing a nested inferred type argument.
There is the \texttt{F6} generic method call containing one type parameter.
The \texttt{temp} variable and the type argument’s hint (\texttt{I2<\_, A>}) are used to determine the inferred nested type argument, which is \texttt{int}.
During the process, multiple rules for inference, such as inheritance and variance, are applied.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class A {}
class B : A {}
interface I2<T1, out T2> {}
class C2<T1, T2> : I2<T1, T2> {}
void F6<T1>(T1 p1) {}
...
F6<I2<_, A>>(new C2<int, B>());
\end{lstlisting}
\caption{Nested inferred type argument}
\label{img74:example2}
\end{figure}
\par
Figure \ref{img75:example3} shows an example where the nullability inference is a part of the type argument deduction.
The \texttt{F10} call site has an inferred type argument with an appended question mark determining the nullability of the inferred type argument. 
The inferred type argument would be \texttt{string} if there wouldn't be the appended question mark. 
However, the question mark is used to hint to infer \texttt{string?}.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
void F10<T>(T p1) {}
...
F10<_?>("");
\end{lstlisting}
\caption{Inferred type argument nullability hint}
\label{img75:example3}
\end{figure}
\par
Figure \ref{img76:example4} shows an example of constructor type inference, which uses a target type to infer type arguments of the new \texttt{new C2<\_>()} expression. 
The target type is a type of the \texttt{C4} constructor parameter resulting in the inferred \texttt{int} type argument.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C1<T> {}
class C2<T> : C1<T> {}
class C4 
{
  public C4(C1<int> p1) {}
}
...
new C4(new C2<_>());
\end{lstlisting}
\caption{Target-typed object creation expression}
\label{img76:example4}
\end{figure}
\par
Figure \ref{img77:example5} shows an example of an advanced binding order of arguments. 
The top-level object creation needs the type of the constructor’s argument to determine its type parameter. 
For this purpose, the nested object creation expression is bound without the target to provide this type of information.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C1<T> {}
class C5<T> : C1<T>
{
    public C5(T p1) {}
}
...
new C5<_>(new C5<_>(1));
\end{lstlisting}
\caption{Advanced arguments binding -- Without target type}
\label{img77:example5}
\end{figure}
\par
Figure \ref{img78:example6} is the advanced scenario of a previous use case where the first argument can’t be bound because type inference failed during the attempt to bind it without a target type.
The failure is caused by a lack of type information. 
However, the second argument provides enough type information to infer a type parameter of the \texttt{C3} class. 
After the bound, the new \texttt{new C2<\_>()} expression is tried to bound again with the inferred target type.
After that, both inferred type arguments are resolved to the \texttt{int} type.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C1<T> {}
class C2<T> : C1<T> {}
class C3<T>
{
   public C3(C1<T> p1, T p2) {}
}
...
new C3<_>(new C2<_>(), 1);
\end{lstlisting}
\caption{Advanced arguments binding -- With target type}
\label{img78:example6}
\end{figure}

\newpage

\par
Figure \ref{img79:example7} shows the most advanced scenario where type the binding order and type inference uses several things to infer the \texttt{new C9<\_,\_,int,\_>(1)} expression. 
We will focus on how the type parameters of the \texttt{C9} class are gradually inferred. 
The \texttt{T3} type parameter is inferred by using the provided hint in the type argument list, which is \texttt{int}. 
The \texttt{T1} type parameter is inferred by using a type of constructor’s argument \texttt{p1}, which is \texttt{int}.
The \texttt{T4} type parameter is inferred by using the type parameter’s dependency using the \texttt{T3} type parameter. 
The type parameter is resolved to \texttt{int}. 
The \texttt{T2} type parameter is resolved by using the target type given by the \texttt{F1} method parameter \texttt{p1}. 
This type information is received in the second try of binding the argument using the target type. 
The \texttt{T1} type parameter of the \texttt{F1} method is determined based on its second parameter type, which is the \texttt{int} type.
\begin{figure}[!h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
class C1<T> {}
void F1<T>(C1<T> p1, T p2) {}

class C9<T1, T2, T3, T4> : C1<T2> where T4 : C1<T3>
{
    public C9(T1 p1) {}
}
...
F1(new C9<_,_,int,_>(1), 1);
\end{lstlisting}
\caption{Constructor type inference -- All in one}
\label{img79:example7}
\end{figure}
\par
Based on the previous examples, the solution can be considered robust enough to solve complicated examples.

\newpage

\section{LDM Meeting Summary}

LDM discussed the proposal on 7th February 2024. 
Besides the overall summary of the proposal with additional questions, the LDT agreed to continue with moving the proposal forward. 
Although it is not going to present the change in the upcoming C\# 13, it is planned to ship this feature with some modifications in the following releases. 
The summary \cite{online:mettingSummary} of the meeting and the following discussion \cite{online:mettingSummaryDisc} are published on the C\# GitHub repository.