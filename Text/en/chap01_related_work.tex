\chapter{Related work}

In the introduction, we presented the programming language C\# and its possible improvement of type inference. 
This chapter continues by describing relevant sections of the C\# language and its type inference algorithm to understand the possible barriers to implement improved type inference. 
As a primary source of inspiration for the improvement, we will explore Hindley-Milner type inference in more detail and describe its modification in Rust and C\# programming languages. 
For the third goal of this thesis, we will mention relevant C\# language issues presented on the GitHub repository, which we use later to prioritize the improvement features to make it more likely to be accepted by \ac{LDM}. 

\section{C\# programming language}

\info{Explain purpose of this section}
Although C\# language features complement each other, we try to extract only relevant components for type inference in this section. 
We describe the type system, including C\# generics and their possibilities. 
Then, we mention unrelated language constructs that influence the type inference, and we have to count on them in proposing improved type inference. 
At the end of this section, we list types of type inference in C\# and describe them in necessary detail for the following chapters.

\subsection{Type system}

\info{Value/reference types}
\info{Inheritance}
As we mentioned in the introduction, each variable and expression returning a value has to have a type in the C\# type system \cite{online:cSharpTypeSystem} called the \ac{CTS}.
Its fundamental characteristic is type inheritance, where every type directly or indirectly inherits a base type \texttt{System.Object}, as you can see in the picture \ref{img04:typeSys}.
This chain of inheritance forms a tree, meaning that it is prohibited to inherit more than one type.
Types are divided into value and reference types.
Value types consist of built-in numeric types, structures (\texttt{struct}), and enumeration (\texttt{enum}).
Compared to classes (\texttt{class}) and records (\texttt{record}) belonging to reference types, value types can't be inherited by other types.
The last relevant member of reference types is interface (\texttt{interface}), which can extend multiple interfaces and be implemented by \texttt{class}, \texttt{record}, or \texttt{struct}.
\par
\begin{figure}[b!]
\centering
\includegraphics[width=140mm, height=100mm]{../img/value-reference-types-common-type-system.png}
\caption{The C\# type system \cite{online:cSharpTypeSystem}.}
\label{img04:typeSys}
\end{figure}
\par
\info{Nullability analysis}
C\# type inference infers, besides a type, its nullability, determining if it is possible to assign \texttt{null} value to that type.
C\# implicitly allows to assign \texttt{null} values to reference types indicating invalid value.
Since C\# 2.0 \cite{online:csHist}, it allows to assign \texttt{null} values to nullable value types, which are generic wrappers around value types.
Because assigning \texttt{null} value is referred to as a billion-dollar mistake, C\# 8.0 introduces optional settings prohibiting it and created nullable reference types explicitly allowing \texttt{null} assignment as a way of interaction with legacy code not using the feature.
\par
\info{Generic types and methods}
An essential part of the type system is C\# Generics, allowing parametrization of types and methods by other types. 
An example of a generic class is \texttt{System.Collections.Generic.List<T>} representing resizeable mutable array where  \texttt{T} represents arbitrary data type, which we want to have a collection of. 
Providing a type argument for  \texttt{T}, we create a new type where the type argument replaces the usages of  \texttt{T}.
\par
\info{Generic constraints}
Because a type parameter can be arbitrary, C\# treats it as a \texttt{System.Object}, which is insufficient in cases where the type parameter should provide special behaviour distinct from \texttt{System.Object}.
This requirement is achieved by type constraints, which restrict a set of types that can be passed to the parameter.
Several types of restrictions can be applied to type parameters in order to enable more actions on values of the restricted type parameters.
We can see examples of type constraints in the following code \ref{img05:typeConst}, where we use implementation restriction forcing the \texttt{T} to implement an interface providing API for comparing values with the same type.
The second restriction forces the type argument to have a default constructor.
Another restriction concerns an obligation that the type will be a value type or the type has to be non-nullable.
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
class MyList<T> : where T : IComparable<T>, new()
{  
	private T[] myBuffer;
	
	int CompareOnIndicies(int idx1, int idx2) {
		return myBuffer[idx1].CompareTo(myBufffer[idx2])	
	}
}
\end{lstlisting}
\caption{C\# type constraints.}
\label{img05:typeConst}
\end{figure}
\par
\info{Variance and contra-variance}
The last feature of generics influencing type inference is the concept of type variance.
Initially, type parameters are invariant, meaning an obligation to assign a generic type to another generic type having the same types of type parameters.
Generic interfaces introduce additional modifiers (\texttt{in}, and \texttt{out}) of type parameters, which allow to assign a type with the more specialized type argument to a type with the less specialized type argument or vice-versa respectively.
\par
\info{Overloading}
We end this subsection by presenting method overloading. 
C\# allows the definition of multiple methods with the same and count of type arguments having different parameters. 
We will see in the following chapters why this feature is one of the barriers to implement strong and efficient type inference.

\subsection{Relevant constructs}

\info{Dynamic}
C\# type inference mostly happens at compile time, with one exception. 
We previously mentioned that C\# requires knowing the types of all variables and expressions during compilation. 
It turned out that the possibility of expressing type, which is unknown at compile time, became crucial for interoperability with other dynamic typed languages. 
To make the interoperability easier, C\# introduced a dynamic keyword that can be used as an ordinary type, which causes late binding. 
Internally, the type is \texttt{System.Object}, however, the compiler skips its binding and postpones it to the runtime. 
This feature creates the exception when type inference happens at runtime, although the compiler still attempts to check expressions containing dynamic values to reveal possible errors. 
This process will be explained in the following section.
\unsure{Code example}
\par
\info{Implicit typed lambdas}
The next language construct influencing type inference is an anonymous function, also known as Lambda, which, instead of declaring a dedicated method with a signature and a body, allows to specify only the body with untyped parameters on places where a function delegate is required. 
Type inference infers its signature based on the surrounding context.
\unsure{Code example}
\par
\info{Object creation expression and initializers}
The last language feature which will take part in the improved type inference are initializers used as a shortcut during an object instantiation.
The most simple one is an object initializer that allows to assign values to the object's fields in a pleasant way instead of assigning them separately after the initialization.
The second type of initializers regard arrays and collections.
Array initializers are used to create fixed arrays with predefined content.
Under the hood, each of the items in the initializer is assigned to the corresponding index of the array after the array creation.
Collection initializers are similar to an array initializer defined on collections which are determined by implementing \texttt{ICollection<T>} interface.
One of the interface's declaring methods is \texttt{void Add<T>(T)} with adding semantic.
Each type implementing this interface is allowed to use an initializer list in the same manner as an array initializer.
It's just a sugar code hiding to call the `Add` method for each item in the initializer list.
The last type of initializer uses indexer to store referred values on predefined positions.
\unsure{Code example}

\subsection{Type inference}

\info{Introduce kinds of type inferences}
\info{Method type inference}
There are many contexts, where type inference occurs in C\#.
We mention five contexts which will regard our improvement.
The first one regards \texttt{var} keyword which is used in the variable declaration as we can see in the code \ref{img09:var}.
It lets the compiler decide the type of variable based on type of initializing value which implicates that we can't use the keyword in declarations without initializing value.
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
var myVariable = "string";
\end{lstlisting}
\caption{\texttt{var} keyword}
\label{img09:var}
\end{figure}
\par
The second type inference and the most complex one is the method type inference used during generic method call binding when type arguments are not given.
We can see a situation when the method type inference deduces \texttt{System.String}, \texttt{System.Int32} and \texttt{System.Int32} as type arguments of the \texttt{MyMethod} method in the following code \ref{img06:typeInference}.
We can notice several tasks, which the type inference has to be capable of.
Regarding \texttt{T1} type parameter, the type inference has to find common type between  the first and the second type parameter.
Regarding \texttt{T2} type parameter, the type inference has go into type arguments of generic type of parameter and the argument, check if the type are compatible and then match the type parameter against type argument of the third parameter.
The most challenging are lamdas, which it's return type has to be inferred after all arguments of that lambda are inferred. 
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
Helper.MyMethod((long)1, 1, new List<int>(), (p1) => p1 + 1);

class Helper {
  static void 
  MyMethod<T1, T2, T3>(T1 p1, T1 p2, IList<T2> p3, Func<T2,T3> p4) 
  { ... }
}
\end{lstlisting}
\caption{C\# Method type inference deduces the method type arguments.}
\label{img06:typeInference}
\end{figure}
\par
As you can see, the method type inference is a complex process containing many several steps.
We provide a description of the algorithm \cite{online:csTypeInference} in the following figure \ref{img07:methodTypeInference} with high-level explanation of its steps.
The algorithm runs in steps which are repeated until all of type arguments are deduced or fails when there are unsatisfied requirements or not enough information for determining all type arguments.
Before we show the algorithm, we have to present definitions which are used by the algorithm.
\par
%\begin{defn}
%Fixed/Unfixed, Type variable
%\label{def01:a}
%\end{defn}
%\par
%\begin{defn}
%Input type
%\label{def02:b}
%\end{defn}
%\par
%\begin{defn}
%Output type
%\label{def03:c}
%\end{defn}
%\par
%\begin{defn}
%Dependence
%\label{def04:d}
%\end{defn}
\par
\begin{figure}
\begin{framed}
\textbf{Input:} a method call \texttt{M($\mathtt{E_1, ..., E_x}$)} and its signature\\
\hspace*{\algorithmicindent} \texttt{$\mathtt{T_e}$ M<$\mathtt{X_1, ..., X_n}$>($\mathtt{T_1 p_1, ..., T_x p_x}$)}\\
\textbf{Output:} $X_1, ..., X_n$
\begin{algorithmic}
\State $B_{lower}, B_{upper}, B_{exact}, F \gets []$
\State \texttt{FirstPhase()}
\State \texttt{SecondPhase()}
\State \textbf{def} FirstPhase:
\State \ \ \textbf{foreach} $E_i$:
\State \ \ \ \ \textbf{if} $E_i \in AnonymousFunctions$:
\State \ \ \ \ \ \ $InferExplicitParameterType(E_i, T_i)$
\State \ \ \ \ \textbf{if} $E_i\ has\ a\ type\ U$:
\State \ \ \ \ \ \ \textbf{if} $isValueParameter(p_i)$:
\State \ \ \ \ \ \ \ \ $InferLowerBound(U, T_i)$
\State \ \ \ \ \ \ \textbf{elif} $isReferenceParameter(p_i) \vee isOutputParameter(p_i)$:
\State \ \ \ \ \ \ $InferExact(U, T_i)$
\State \ \ \ \ \textbf{elif} $isInputParameter(p_i) \wedge isInputArgument(E_i)$:
\State \ \ \ \ \ \ $InferExact(U, T_i)$
\State \ \ \ \ \textbf{elif} $isInputParameter(p_i)$:
\State \ \ \ \ \ \ $InferLowerBound(U, T_i)$
\State \textbf{def} InferSecondPhase:
\State \ \ $X_{independent} \gets \forall X_i : F[i] = null \wedge \nexists X_e : DependOn(X_i, X_e)$
\State \ \ $X_{dependent} \gets \forall X_i\ :\ F[i] = null \wedge (\exists X_e : DependOn(X_e, X_i) \vee B_{lower}[i] \cup B_{exact}[i] \cup B_{upper}[i] \neq empty)$
\State \ \ \textbf{if} $X_{independent} \neq empty$:
\State \ \ \ \ \textbf{foreach} $X_s \in X_{independent}$ \textbf{do} $Fix(X_s)$  
\State \ \ \textbf{elseif $X_{independent} = empty \wedge X_{dependent} \neq empty$}:
\State \ \ \ \ \textbf{foreach} $X_s \in X_{dependent}$ \textbf{do} $Fix(X_s)$ 
\State \ \ \textbf{elseif} $X_{independent} \cup X_{dependent} = empty$:
\State \ \ \ \ $Failed()$
\State \ \ \textbf{else}:
\State \ \ \ \ \textbf{foreach} $E_i : \exists X_e : F[e] = null \wedge X_e \in outputTypes(T_i) \wedge X_e \notin inputTypes(T_i)$ \textbf{do} $InferOutputType(E_i, T_i)$ 
\State \ \ \ \ $goto(17)$
\end{algorithmic}
\end{framed}
\caption{Method type inference: Phases}
\label{img07:methodTypeInference}
\end{figure}
\par
\begin{figure}
\begin{framed}
\begin{algorithmic}[1]
\State \textbf{def} InferOutputType(E, T):
\State \ \ \textbf{if} $isAnonymousFunction(E) \wedge (isDelegate(T) \vee isExpressionTree(T))$:
\State \ \ \ \ $InferLowerBound(InferReturnType(E), getReturnType(T))$:
\State \textbf{def} InferExplicitParameterType(E, T):
\State \ \ \textbf{if} $isExplicitlyTypedAonymousFunction(E) \wedge (isDelegate(T) \vee isExpressionTree(T))$:
\State \ \ \ \ $U_1, ..., U_v \gets getParameterTypes(E)$
\State \ \ \ \ $V_1, ...,s V_v \gets getParameterTypes(T)$
\State \ \ \ \ \textbf{foreach} $U_i, V_i$ \textbf{do} $InferExact(U_i, V_i)$ 
\State \textbf{def} InferExact(U, V):
\State \ \ \textbf{if} $\exists i : V = X_i \wedge F[i] = null$:
\State \ \ \ \ $B_{exact}[i].Add(U)$
\State \ \ \textbf{elif} $V\ is\ $\texttt{$V_1$[...]}$\ \wedge\ U\ is\ $\texttt{$U_1$[...]}$\ \wedge\ V.rank() = U.rank()$:
\State \ \ \ \ $InferExact(U_1, V_1)$
\State \ \ \textbf{elif} $V\ is\ $\texttt{$V_1$?}$\ \wedge\ U\ is\ $\texttt{$U_1$}:
\State \ \ $InferExact(U_1, V_1)$:
\State \ \ \textbf{elif} $V\ is\ $ \texttt{C<$V_1,...V_n$>}$\ \wedge\ U\ is\ $\texttt{C<$U_1,...U_n$>}:
\State \ \ \ \ \textbf{foreach} $V_i, U_i$ \textbf{do} $InferExact(U_i, V_i)$
\State \textbf{def} InferLowerBound(E, T):
\State \ \ \textbf{if} $\exists i : V = X_i \wedge F[i] = null$:
\State \ \ \ \ $B_{lower}[i].Add(U)$
\State \ \ \textbf{elif} $V\ is\ $\texttt{$V_1$?}$\ \wedge\ U\ is\ $\texttt{$U_1$?}:
\State \ \ \ \ $InferLowerBound(U_1, V_1)$
\State \ \ \textbf{elif} $V\ is\ $\texttt{$V_1$[...]}$\ \wedge\ U\ is\ $\texttt{$U_1$[...]}$\ \wedge\ V.rank() = U.rank()$:




\State \textbf{def} InferUpperBound(E, T):
\State \textbf{def} InferReturnType(E, T):
\end{algorithmic}
\end{framed}
\caption{Method type inference: Inferences}
\end{figure}
\par
\info{Array type inference}
The third type inference happens in array initializers when the type of the array should be deduced from the initializer list.
We can see an example of situation, when the type inference is used for determining \texttt{myArray} type in the following code \ref{img08:arrayTypeInference}.
The most specialized common type is just adjusted already mentioned type inference algorithm where is just one type parameter and all initializer items are lower bounds of that type variable.
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
var myArray = new[] {new object(), "string"};
\end{lstlisting}
\caption{C\# Method type inference algorithm.}
\label{img08:arrayTypeInference}
\end{figure}
\par
\info{Target-typed inference}
The fourth type inference regards inference based on target type.
The example of these situations can be seen in the following example where we use target-typed \texttt{new()} operator allowing to skipping creating type which is provided by the target type, variable type in this case.
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
List<int> myList = new();
\end{lstlisting}
\caption{Target-typed \texttt{new()} operator.}
\label{img09:targetTypeInference}
\end{figure}
\par
\info{Dynamic checking}
The last group what we have to mention is rather type checking than type inference.
As we mentioned in the previous section, \texttt{dynamic} keyword is used to enable late binding on the expression containing dynamic expression.
Because of late binding, the compiler can't check instance method calling at compile time to prevent type errors at runtime.
However, there are situations, where the compiler can partial type check expressions like method calls.
You can see a situation, where despite of late-binding there is an obvious error where we try to pass arguments with \texttt{System.Int32} and \texttt{System.String} types to parameters with the same type.
Method type inference as we presented doesn't allow to infer \texttt{System.Object} when at least one bound doesn't contains that type causing type inference error at runtime.
To prevent these situations, where error are not related to dynamic values, the compiler tries to infer the types ignoring the dynamic values.
In case of type conflicts in the variable's bounds, the error is announced at compile time instead of runtime.
\par
\begin{figure}
\begin{lstlisting}[style=csharp]
dynamic dynamicValue = null;
Helper.MyMethod(1, "string", dynamicValue);

class Helper {
 static
 void MyMethod<T1, T2>(T1 p1, T1 p2, T2 p3) 
  { ... }
}
\end{lstlisting}
\caption{Type inference with dynamic argument.}
\label{img010:dynamicChecking}
\end{figure}

\section{Roslyn}

\info{Intro}
The implementation of C\# type inference can be found in the Roslyn compiler, as open-source compiler of C\# and VisualBasic developed at GitHub repository.
In this section we present Roslyn's architecture to better understand the context and restrictions which we have to consider to be able to plug the improved type inference into the compiler.
\par
\change{Overview of compilation pipeline}
\change{Binder}
\change{OverloadResolution}
\change{MethodTypeInferrer}
\change{NullableWalker}
\change{Dynamic biding vs. runtime binding}

\section{Hindley-Millner type inference}

\change{Hindley-Millner type system}
\change{Set of rules}
\change{Restriction and possible extensions}

\section{Rust type inference}

\change{Rust type system}
\change{Type inference context}
\change{Type inference across multiple statement}
\change{Constructor type inference}

\section{Github issues}

\change{Mention related Github issues and csharplang repo.}
\change{Roslyn and csharplang repo}
\change{Proposal champions}
\change{Related issues}
