\chapter{Introduction}

C\# is an object-oriented programming language developed by Microsoft. 
It belongs to the strongly typed languages helping programmers to possibly reveal bugs at compile time. 
The first part of this thesis focuses on exploring type systems of strongly typed languages and proposes an improvement to the C\# type system. 
The second part concerns the implementation of the improvement in the current C\# compiler and the creation of a proposal that should have sufficient potential to be discussed by the \ac{LDT} accepting new C\# language features.

\section{Improving C\# type system} \label{sect01:imprv}

A key feature of strongly typed languages is type safety, prohibiting operations on incompatible data, achieved by determining data types at compile time. 
The easiest way for a compiler to reason about types of variables in the code is by providing type annotations determining the data type that these variables hold. 
Figure \ref{img01:csharp_type_sef} shows an usage of type annotations written in the C\# programming language.
The type declaration of the \texttt{people} variable guarantees that the following attempt to concatenate the \texttt{"Tom"} string to that variable will be reported as an error at compile time since the operation is not defined for a pair of the \texttt{List<string>} type and \texttt{string} type.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
List<string> people = new List<string>() {"Joe", "Nick"};
people += "Tom"; // Error reported during compilation
\end{lstlisting}
\caption{Type safety in the C\# programming language.}
\label{img01:csharp_type_sef}
\end{figure}
\par
On the other hand, types can have long names, forcing the programmer to write more code to annotate the variable declaration or object creation, as we can see in the example.
This disadvantage of strongly typed languages can be removed by \textit{type inference} when a missing type annotation can be deduced using the context. 
Taking the example shown above, one of the \texttt{List<string>} type annotations could be removed since the type of \texttt{people} variable declaration can be deduced from its initializing value or the type of object creation can be deduced from the type of the assigning variable.
There is an example of C\# type inference in Figure \ref{img02:csharp_type_inf}, where the \texttt{var} keyword is used to trigger type inference determining a type of \texttt{people} variable to be the \texttt{List<string>} type.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var people = new List<string>();
\end{lstlisting}
\caption{Type inference in the C\# programming language.}
\label{img02:csharp_type_inf}
\end{figure}
\par
The power of type inference varies in strongly typed languages.
An example of the difference can be seen in type arguments deduction of generic methods. 
In C\#, a generic method is a method that is parametrized by types besides common parameters, as can be found in Figure \ref{img03:csharp_gen_meth}.
There is a generic method \texttt{GetField} enabling to return a value of \texttt{o}'s field with the \texttt{fieldName} name.
The type of returned value is generic parameter \texttt{T} since it depends on the type of object's field.
The \texttt{name} variable is initialized by using the method to retrieve a \texttt{person}'s name, which is supposed to be a string.
There is a redundancy in that statement since the type argument list of the \texttt{GetField} method could be removed, and \texttt{T} could be deduced from the type of \texttt{name} variable, which has to be compatible with the return type.
However, the current version of C\# type inference fails to deduce it.
\begin{figure}
\begin{lstlisting}[style=csharp]
T GetField<T>(object o, string fieldName) { ... }

object person = ...
string name = GetField<string>(person, "name");
\end{lstlisting}
\caption{C\# Type inference of generic methods.}
\label{img03:csharp_gen_meth}
\end{figure}
\par
A similar concept of generic methods was introduced in the Rust \cite{online:rust} programming language, which belongs to strongly typed languages too.
Figure \ref{img04:rust_gen_meth} shows a definition of the generic method \texttt{GetField}, which is equivalent to the C\# method mentioned in the previous example.
There is an equivalent initialization of \texttt{name} variable declaration starting with the \texttt{let} keyword, where Rust type inference deduces the type argument \texttt{T} to be the \texttt{\&str} type utilizing the type information from the \texttt{name} variable declaration.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
fn GetField<T>(o: &object, fieldName: &str) -> T { ... }

let person: &object = ...;
let name: &str = GetField(person, "name");
\end{lstlisting}
\caption{Rust Type inference of generic methods.}
\label{img04:rust_gen_meth}
\end{figure}
\par
Although Rust is younger than C\# and has a different type system, it managed to make type inference more powerful in the context of strongly typed languages to significantly save type annotations typing.
The first goal of this thesis is to investigate if the similar level of type inference can be achieved in C\# and improve C\# type inference to be used in more scenarios saving type annotations typing.
\par
The investigation explores type system requirements and type inference differences to achieve a desired level of type inference by formalizing Rust and C\# type inference.
These formalizations can be partially identified as a part of the existing Hindley-Millner \cite{online:yHM} type inference formalization, which helps to reason about the inference in these languages.
Traditional Hindley-Millner type inference is defined in the Hindley-Millner type system \cite{online:wikiHM}, where it can deduce types of all variables in an entirely untyped code. 
The power of type inference is caused by properties of the type system, which, in comparison with the C\# type system, doesn't use type inheritance or overloading. 
Despite the differences, Hindley-Millner type inference can be modified to work with other type systems like Rust or C\#, causing limited use cases where it can be applied.
Observing the influence of differences between these type systems on type inference will help to understand a limitation of possible type inference improvement in C\#.

\section{Implementation}

The first part of the thesis explores limitations of C\# type inference and proposes an improvement.
The first goal of the second part tests the improvement by implementing it in an official C\# compiler, Roslyn \cite{online:roslynRepo}, which is an open-source project managed by Microsoft.
The prototype is used to explore potential implementation issues which the improvement can cause, and that helps to adjust the improvement to be potentially enabled in the C\# compiler.
\par
Although the compiler is managed by the company, it has an open-source development, which makes contributions from interested people possible to be merged into the production.
Although it is sufficient to make a \textit{pull request} containing a fix for solving compiler issues to be merged, language design improvements, similar to what the thesis will propose, require a special process of validating the actual benefit.
The process starts by proposing new C\# features in public discussions of the C\# language repository \cite{online:langRepo}, where everyone can add his/her ideas or comment on others' ideas. 
It is preferred to use a predefined template \cite{online:proposalTemplate} for describing the idea proposing the feature in order to make the idea more likely to be discussed by the team responsible for accepting new language features. 
The template includes motivation, detailed description, needed C\# language specification \cite{online:langSpec} changes, and other possible alternatives.
The second goal of this part is to create the improvement as the language proposal, which would be presented to the team in order to have the potential to be a part of the current C\# language.
The process of language proposal ends with \ac{LDT} accepting or declining it. 

\section{Summary} \label{sect:summary}

We summarize goals of this thesis in the following list:

\begin{enumerate}
  \item[G1.] Explore possibilities of type inference in strongly typed languages
  \item[G2.] Improve C\# type inference based on previous analysis
  \item[G3.] Implement the prototype in Roslyn
  \item[G4.] Create an proposal containing the improvement
\end{enumerate}