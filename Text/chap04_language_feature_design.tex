\chapter{Language feature design} \label{sect09:lang}

The language feature design will be based on existing ideas of the partial type inference mentioned in the previous chapter \ref{sect04:github} and will be validated by the given requirements.
Besides the language feature design, the last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements.
\par
The mentioned ideas can be categorized into three groups. 
The first group consists of \textit{Target-typed inference} \ref{sect06:targetType} and \textit{Type inference based on constraints} \ref{sect11:is6}, which improve method type inference algorithm. 
The second group consists of \textit{Default type parameters} \ref{sect07:is1}, \textit{Generic aliases} \ref{sect08:is2}, \textit{Named type parameters} \ref{sect09:is3}, \textit{Inferred type argument} \ref{sect10:is4}, and \textit{Relocation} \ref{sect13:is8}, which regards partial type inference. 
The third group consists of \textit{Constructor type inference} \ref{sect14:is9} and \textit{Inferred method return type} \ref{sect12:is7}, which introduce type inference in new C\# constructs. 
Inferred method return type is not in the scope of this work, although it is mentioned in the last section as a future improvement that will be difficult to implement. 
The first group is discussed in relation to constructor type inference, where potentially applied method type inference can be improved without introducing breaking changes. 
The second group is discussed in relation to partial type inference, which is an objective of the championed issue.

\section{Partial method type inference}

Discussions regarding partial type inference can be further divided into two groups. 
The first group provides hints in type parameter declarations, which are done by default type parameters. 
Since it has to be done in the declaration, partial type inference wouldn’t work with already existing code without adjusting it.
For this reason, the work excludes the idea.
\par
The second group provides hints through the usage. 
Generic aliases don’t work for methods, and also, it doesn’t seem to be useful when the inferred type arguments don’t represent some common specialization of generic type.  
An example of the specialization is \texttt{StringDictionary<TValue>} mentioned in the previous chapter \ref{sect08:is2}.
\par
Named type parameters are excluded since providing that would be an uncommon new feature that has no equivalent in other well-known languages like Java, C++, Kotlin, and Rust. 
We believe it would be confusing to introduce it to the users since it is a controversial change.
\par
Relocation doesn’t solve the problem of specifying all type arguments. 
It just compacts type argument lists into one.
\par
The last discussion regards using inferred type argument, which will be a core of the proposed design for the following reasons. 
It is already used in different languages, like a star in Kolin and Java or an underscore in Rust and F\#. 
So, it is more common and intentional than previously mentioned ideas. 
It introduces no or at least minimal syntax changes into the language, which makes the usage simple, and it solves the problem of specifying all type arguments.

\subsection{Syntax}

The choice of the syntax is based on six use cases where the expression of inferred type argument can be used or could be used in the future. 
Table \ref{table2:useCasesChar} shows examples of these usages, which identify necessary syntax requirements.
\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | } 
  \hline
  Generic method call & \texttt{Foo<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Object creation expression & \texttt{new Bar<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Variable declaration & \texttt{Bar<\{SYNTAX\}> temp = ...}\\
  \hline
  Array type & \texttt{\{SYNTAX\}[]}\\
  \hline
  Inferred type & \texttt{\{SYNTAX\}}\\
  \hline
  Inferred nullable type & \texttt{\{SYNTAX\}?}\\
  \hline
\end{tabular}
\end{center}
\caption{Use cases containing syntax for inferred type argument.}
\label{table2:useCasesChar}
\end{table}
\par
\textbf{Generic method call} use case represents a situation where the syntax is used during a generic method call.
\par
\textbf{Object creation expression} represents the usage in the construction of generic type.
\par
\textbf{Variable declaration} represents the potential usage in the variable type declaration, which is not in the scope of this work. 
However, it is a natural continuation of partial type inference extension where the inferred type arguments are determined by the surrounding context.
\par
\textbf{Array type} has a different syntax of type argument list specifying a type of the contained elements. 
The type of the elements can also be inferred, and the proposed syntax has to offer a convenient way to express an array type with the inferred element type.
\par
\textbf{Inferred type} doesn’t have to be contained only in the type argument list.
The previous chapter presented the \texttt{var} keyword used in the variable declaration, whose type is determined by the type of initializing value. 
C\# also offers a discard pattern \cite{online:discard} represented by an underscore, which is commonly used as a placeholder for variables that are not intentionally used in the code. 
Since type argument inference relates to that, the syntax should be at least aligned with already existing related syntax. 
The alignment will help the syntax to be naturally used without using language documentation.
\par
\textbf{Inferred nullable type} can be used to specify nullability of the inferred type which will be useful in scenarious where non-nullable and nullable code is mixed together.
\par
There are several syntax variants that can be used for inferred types. 
The work presents the most relevant variants that appeared in the mentioned ideas and comments on the advantages and disadvantages for each variant.

\subsubsection{Diamond operator} 

Syntax consists of a pair of two angle brackets \texttt{<>}.
It is used as an empty type argument list determining that the type name or method name is generic.
\par
Figure \ref{img40:opDi1} demonstrates the usage in generic method calls of \texttt{Foo1} and \texttt{Foo2}. 
The declarations of these methods are not important for the purpose of showing the pros and cons. 
Calling the \texttt{Foo1} method with an empty argument list doesn’t make much sense since method type inference is enabled by default without using angle brackets. 
Calling the \texttt{Foo2} method with nested usage of the diamond operator allows limited partial type inference when the diamond operator is used inside the type argument list. 
The \texttt{Bar<>} type partially hints to the compiler the generic type name without specifying the type arguments. 
However, the usage is problematic when there are multiple generic types with the same name since it can cause ambiguity between them. 
This problem is described in the next example.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<>(arg1, arg2, arg3);
Foo2<Bar<>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Diamond operator - generic method call.}
\label{img40:opDi1}
\end{figure}
\par
Figure \ref{img41:opDi2} shows the usage in object creation expression. 
The first statement containing the \texttt{Bar<>} name has the advantage of expressing the will to infer the type’s type arguments, which is necessary in comparison to the previous example since the object creation doesn’t offer type inference. 
If the type inference were potentially turned on by default, it would introduce a breaking change. 
However, there is also a disadvantage of the usage since it doesn’t specify the arity of the generic type. If there were multiple generic types differing in arity, it would complicate the already mentioned overload resolution phase since all constructors from these generic types would have to be considered. The process would be computationally demanding. 
A possible solution would be the following restriction. 
Usually, there is not more than one generic type with the same name. 
So when there is just one type of that name, the diamond operator would be allowed to use it since the name determined one specific generic type. 
In the example, \texttt{Baz<>} would refer to the \texttt{Baz<T1, T2>} generic type since there is no other generic type with the same name, causing the ambiguity.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
new Bar<>(...);
new Baz<>(...);

class Bar { ... }
class Bar<T1> { ... }
class Bar<T1, T2> { ... }

class Baz<T1,T2> { ... }
\end{lstlisting}
\caption{Diamond operator - object creation expression.}
\label{img41:opDi2}
\end{figure}
\par
The third example is shown in Figure \ref{img42:opDi3}, where the generic \texttt{Wrapper} class is used to specify the wrapping generic type. 
However, it doesn’t offer to specify any type arguments, which is limiting when the compiler can’t infer all of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Wrapper<> temp = ...
\end{lstlisting}
\caption{Diamond operator - variable declaration.}
\label{img42:opDi3}
\end{figure}
\par
Figure \ref{img43:opDi4} shows the operator as an indicator of the inferred element of the array type. 
Since there isn’t a known popular language similar to C\#, which would contain a similar construct, the usage is considered to be unintentional for most of the users.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
<>[] temp = ...
\end{lstlisting}
\caption{Diamond operator - array type.}
\label{img43:opDi4}
\end{figure}
\par
Similar conclusions are made in the last example in Figure \ref{img44:opDi5} where the \texttt{<>} operator has the same functionality as the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
<> temp = ...
\end{lstlisting}
\caption{Diamond operator - inferred type.}
\label{img44:opDi5}
\end{figure}
\par
The \texttt{?} nullable operator can be appended to the diamond operator.
In general, each syntax introducing a placeholder which is not a whitespace is suitable for appending the \texttt{?} operator.

\subsubsection{Whitespace separated by commas} 

The syntax would simly skip inferred type argument by whitespace which would allow to specify just the ambiguous type arguments. 
It would also determine the arity of type, which is important for the type name look-up phase of the compiler. 
A natural choice for the separator is commas since it is widely used. 
Another advantage is that this syntax is already used when working with C\# reflaction. 
An example is the following expression \texttt{typeof(Dictionary<,>)}, which returns a class describing the \texttt{Dictionary} type from the standard library.
\par
Figure \ref{img45:opW1} shows the usage when the \texttt{Foo1} generic method is called by
skipping the first and the last type argument, which is inferred by the compiler. 
However, the syntax seems to be messy when it is used in generic methods with many generic type parameters, as can be seen in the \texttt{Foo2} method call. 
Similar thoughts regard the second and third use case.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<, string, List<>, >(arg1, arg2, arg3);
Foo2<,,,int,,>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Whitespace - generic method call.}
\label{img45:opW1}
\end{figure}
\par
The usage with array type seems to be unintentional and would cause changes in the compiler parser. 
Figure \ref{img46:opW4} shows the syntax to express the inferred type of array's element.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
[] temp = ...
Foo<, [], >(arg1, arg2)
\end{lstlisting}
\caption{Whitespace - array type.}
\label{img46:opW4}
\end{figure}
\par
The last use case regarding using the whitespace as an inferred type would probably cause problems with determining declarations of variables. 
Figure \ref{img47:opW5} shows a situation where the compiler can’t determine if it is a variable declaration or a variable assignment. 
Although it could be solved by investigating the surrounding context, we consider that the code comprehension would get worse.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
temp = ...
\end{lstlisting}
\caption{Whitespace - inferred type.}
\label{img47:opW5}
\end{figure}
\par
Since there is no placeholder which will be prepended to the nullable operator, the syntax doesn't work well in the last scenario regarding the nullable operator.

\subsubsection{Underscores separated by commas} 

The syntax is commonly used in other programming languages like F\# or Haskell to represent inferred type arguments, or as a placeholder for discarding variables that are intentionally not used. 
This is considered as a big advantage. 
A disadvantage is the introduction of breaking change because C\# allows the underscore as a type identifier. 
However, that seems to be rather uncommon in the code. 
It seems to be less messy than the previous syntax when a generic type contains many type parameters, as shown in Figure \ref{img50:opU1}.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
new Bar<_, _, List<_>, _,_>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Underscore - object creation expression.}
\label{img50:opU1}
\end{figure}
\par
The usage with array type also seems to work even if it can still be considered uncommon. 
Figure \ref{img51:opU4} shows the usage where we think that the syntax intentionally expresses the inferred type of array’s elements.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_[] temp = ...
\end{lstlisting}
\caption{Underscore - array type.}
\label{img51:opU4}
\end{figure}
\par
The last use case is shown in Figure \ref{img52:opU5} where it clashes with the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_ temp = ...
\end{lstlisting}
\caption{Underscore - variable declaration.}
\label{img52:opU5}
\end{figure}


\subsubsection{\texttt{var} keywords separated by commas} 

The \texttt{var} keyword representing the placeholder is another natural option of the syntax. 
The big advantage of the syntax is the already used the \texttt{var} keyword in the variable declaration, whose meaning is coherent with inferred type arguments. 
However, it starts to raise the question if it brings the advantage of saving keystrokes. 
Figure \ref{img52:opV1} shows a usage of the syntax, which is considered to be unnecessarily long.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<var, string, List<var>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{\texttt{var} - generic method call.}
\label{img52:opV1}
\end{figure}

\subsubsection{Something else separated by commas} 

A different placeholder doesn't make a lot of sense because it needs to assign new meaning to that character in comparison with an underscore, the \texttt{var} keyword, the \texttt{<>} operator, or \texttt{<,,,>} syntax. 
An asterisk can be considered.
However, it can remind a pointer in the context of unmanaged C\# code.

\subsubsection{Conslusion} 

The thesis chooses the underscore as a placeholder for inferred
type argument since the meaning of this character is related to the intention. 
It also seems to be the shortest and synoptical way to skip inferred type arguments. 
The possible breaking change is not an obstacle in this situation since a similar decision was made for the \texttt{var} keyword, and the situation where it can occur seems to be rare. 
Problems with the potential future extension where the underscore can represent inferred type in the variable declaration would be prohibited to not mix it with the \texttt{var} keyword. 
Although the diamond operator is not very useful in a generic method call, it makes sense in object creation expression. 
The usage and analysis of that is covered by later in this work.

\subsection{Method and typename lookup}

The previous section presented the proposed syntax for skipping inferred type arguments using an underscore as a placeholder. 
This section continues with determining what the expression containing the syntax means.
\par
Since an underscore character is a valid type identifier in C\# and there is
1:1 mapping of inferred type arguments to these placeholders, determining the referred generic method containing the proposed syntax is almost unchanged. 
The change is in overload resolution where if the generic method is \textit{partially inferred}, meaning it contains the syntax, the type inference has to be done to determine the type arguments of that method.
\par
An underscore itself can be a nullable or non-nullable type. 
If the inferred type argument has to be a nullable type, the metioned \texttt{?} operator can be appended to the underscore. 
Figure \ref{img53:null} shows an example of using the nullable operator. 
The call of \texttt{Foo} generic method has three type arguments where the first one is inferred by the compiler and which has to be nullable. 
The second type argument is the \texttt{List} type, containing an inferred nullable type argument as well. 
The third type argument doesn’t require the nullable type, so the inferred type can be either nullable or non-nullable.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_?, List<_?>, _>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Inferring nullable type argument.}
\label{img53:null}
\end{figure}
\par
The type name lookup is also almost unchanged. 
If there is an underscore
referring to inferred type argument, it simply ignores the binding of this identifier.
\par
The underscores contained in the type arguments are threatened in the changed type inference algorithm mentioned in the following section.

\section{Method type inference algorithm change}

The thesis extends method type inference by introducing a new type variable bound, which represents inferred type arguments contained in the type argument list. 
Firstly, if a generic method call doesn’t contain a type argument list, the method type inference is unchanged. The change is when the generic method is partially inferred. 
Figure \ref{img54:partInf} shows an example of a partially inferred method \texttt{Foo} containing two type parameters. 
The former algorithm identifies the type arguments as type variables for which it tries to find a unique type. 
The algorithm can be extended to represent placeholders for inferred type arguments as type variables, too. 
Using the example, all three underscores would be represented as three unique type variables besides those representing \texttt{T1} and \texttt{T2} type parameters. 
However, this extension also has to be respected by the order of type variables fixing and inferring. 
A reason can be seen in the \texttt{T2} type variable. 
The \texttt{Dictionary<\_, \_>} can be considered as a bound for the type variable, which has to be respected. 
However, this bound contains other type variables which are not yet known. 
So, the algorithm has to first infer the type variables contained in that bound and then infer the \texttt{T2} type variable. 
The second observation for this extension is a way of inferring the bounds. 
Since type variable bounds can contain other type variables, it is necessary to propagate the relation between the bounds at the time of adding new bounds. 
An example of this can be demonstrated using the given Figure \ref{img54:partInf}. 
The \texttt{Dictionary<\_, \_>} is a bound of the \texttt{T2} type variable. 
The second bound is a type of the \texttt{p2} argument. 
This type gives us bounds for type variables contained in the former bound, which has to be propagated.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_, Dictionary<_, _>>(arg1, new Dictionary<int, int>());

void Foo<T1, T2>(T1 p1, T2 p2)
\end{lstlisting}
\caption{Partially inferred method call.}
\label{img54:partInf}
\end{figure}

\subsection{New definitions}

The proposed algorithm uses two new definitions of dependendencies which are given below.
\begin{defn}[Shape dependence]
An unfixed type variable \texttt{$X_i$} \emph{shape-depends directly} on an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} represents \textit{inferred\_type\_argument} and it is contained in shape bound of the type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{shape-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{shape-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{shape-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{shape-depends on} \texttt{$X_e$}. Thus \textit{shape-depends on} is the transitive but not reflexive closure of \textit{shape-depends directly on}.
\end{defn}
\begin{defn}[Type dependence]
An unfixed type variable \texttt{$X_i$} \textit{type-depends directly on} an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} occurs in any bound of type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{type-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{type-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{type-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{type-depends on} \texttt{$X_e$}. 
Thus \textit{type-depends on} is the transitive but not reflexive closure of \textit{type-depends directly on}.
\end{defn}

\subsection{Algorithm phases}

The required change of the algorithm is presented as an algorithm divided into three sections, which is based on the former method type inference. 
Figure \ref{img54:mainTypeInference1} shows the beginning, the first, and second phases. 
The first step is to identify all type variables, which would be an objective of the type inference. 
This is done by the \texttt{getAllTypeVariables} function, which replaces the underscore placeholders in the provided type arguments (If the type arguments were provided) with new type variables and joins them with type variables representing type parameters of
the method.
Besides the already known three types of bound, the algorithm adds \textit{shape-bound} representing a type argument given in the type argument list.
The reason for a new type of bound is the following. 
When a user provides the type argument, the algorithm should infer the exact same type(not containing any unfixed type variables). 
None of the already introduced type bounds offers this feature. 
An example of this need is described by a potential scenario when there is the \texttt{IList<\_>} type as a type argument. 
When the compiler treats nullability, it wants the hinted type parameter to be non-nullable(not \texttt{IList<\_>?}). 
It can happen, that other bounds would infer the nullable version, and although \texttt{IList<\_>} can be
converted to \texttt{IList<\_>?}, it is not the user’s intention. 
However, the exact bound would allow this.
\par
\texttt{FirstPhase} collects shape bounds from the provided type argument list before the initial  collection of bounds from the argument list.
The referring \texttt{InferShapeBound} is described later with the rest of inferring methods.
\par
\texttt{SecondPhase} now respects newly added dependencies, which forces to infer type variables in the correct order. 
If there are no type variables that are independent, the algorithm relaxes the condition for type variable fixation to break the possible circular dependency, which still has a chance to be resolved. 
In comparison to the former algorithm, the relaxation still has to respect \textit{shape-depends on} relation. 
The reason for that is to prohibit inferred type from being different from the provided ”shape” in the type argument list. 
The next condition is that at least one bound can’t contain an unfixed type variable. 
This requirement ensures at least one candidate, which could be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
Input: method call M<$S_1$,...$S_n$>($E_1$,...$E_x$) and 
       its signature $T_e$ M<$X_1$,...,$X_n$>($T_1$ $p_1$,...,$T_x$ $p_x$)
Output: inferred $X_1$,...$X_n$,...$X_{n+l}$
$B_{lower}$ = $B_{upper}$ = $B_{exact}$ = $B_{shape} = $F = []
$TV$ = getAllTypeVariables(X, S)
FirstPhase()
SecondPhase()
fn FirstPhase():
  S.foreach(s -> InferShapeBound(s, T[s.idx]))
  /*Continuation as the former method type inference*/
fn SecondPhase():
  while (true):
    $TV_{indep}$ = $TV$.filter(x $\rightarrow$ 
      F[x.idx] == null && $TV$.any(x $\rightarrow$ 
        dependsOn(x, y) && shapeDependsOn(x, y) 
        && typeDependsOn(x, y)
      )
    )
    $TV_{dep}$ = $TV$.filter(x $\rightarrow$
      F[x.idx] == null && $TV$.any(y $\rightarrow$ 
        (dependsOn(y, x) || shapeDependsOn(y, x) 
          || typeDependsOn(y, x)) 
        && !$TV$.any(t $\rightarrow$ shapeDependsOn(x, t))
        && ($B_{lower}$+$B_{upper}$+$B_{exact}$+$B_{shape}$).any(b $\rightarrow$ 
            !b.containsUnfixedTypeVariable
        )
      )
    )
    /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Phases of new Method Type Inference}
\label{img54:mainTypeInference1}
\end{figure}

\newpage

\subsection{Collecting Type bounds}

Figure \ref{img55:mainTypeInference2} shows three adjusted inferences, adding new bounds, and presents a new \texttt{InferShape} inference.
The change is in propagating nested type bounds between type variable bounds. 
This is done by the \texttt{Propagate} function, which is invoked after a new bound is added. 
It iterates over all bounds of the type variable and makes additional type inferences for each bound containing an unfixed type variable checked by the \texttt{containsUnfixedTypeVariable} property. 
This step will ensure that the unfixed type variable will receive a bound which is associated with it. 
Using mentioned example \ref{img54:partInf}, this phase propagates the  \texttt{int} type bounds contained in the \texttt{Dictionary<int, int>} type of provided argument to the underscores representing type variables in the \texttt{Dictionary<\_ ,\_>} type argument.
Since the design of the algorithm always adds type bounds received from the left argument of algorithm's functions to the type variable obtained from the right argument of algorithm's functions, the inference has to be done for each transposition of the pair of the added bound and an already collected type variable bound.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Propagate(Type U, int typeVariable) {
  setOf($B_{shape}$[typeVariable],
    $B_{lower}$[typeVariable],
    $B_{upper}$[typeVariable],
    $B_{exact}$[typeVariable]
  ).foreach(b $\rightarrow$
    if (b.containsUnfixedTypeVariable) InferHelper(U, b)
    if (U.containsUnfixedTypeVariable) InferHelper(b, U)
  )
}

fn InferExact(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{exact}$[t.idx].contains(U)) {
    $B_{exact}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferLower(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{lower}$[t.idx].contains(U)) {
    $B_{lower}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferUpper(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{upper}$[t.idx].contains(U)) {
    $B_{upper}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferShape(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null)) {
    $B_{shape}$[t.idx] = U
    Propagate(U, t.idx)
  }
\end{lstlisting}
\caption{\textit{Exact inference}, \textit{Upper-bound inference}, \textit{Lower-bound inference}, \textit{Shape-bound inference}}
\label{img55:mainTypeInference2}
\end{figure}
\par
Table \ref{table3:InferHelper} shows which inference is called based on the inputs. 
For example, if the \texttt{U} represents the added lower bound and \texttt{b} is an exact bound, the algorithm calls the \texttt{InferUpper} function. 
The intuition behind the table is to respect the relation between the bounds of a type variable.
So, for example, all bounds of lower bounds are lower bounds for exact, upper, and shape bounds of that type variable and are exact bounds for each other.
\begin{table}[h!]
\begin{center}
\begin{tabular}{ | c | c | c | c | c | } 
  \hline
   & Lower & Upper & Exact & Shape\\
  \hline
  Lower & InferExact  &  InferUpper & InferUpper & InferLower \\
  \hline
  Upper & InferLower  &  InferExact & InferLower & InferLower \\
  \hline
  Exact & InferLower  &  InferUpper & InferExact & InferExact \\
  \hline
  Shape & InferLower  &  InferUpper & InferExact & InfeExact \\
  \hline
\end{tabular}
\end{center}
\caption{Matrix of \texttt{InferHelper} function.}
\label{table3:InferHelper}
\end{table}

\subsection{Fixation}

Figure \ref{img55::mainTypeInference3} shows the last part of the changed algorithm, type variable fixation. 
The set of candidates is changed to respect the shape-bound ability to express the exact form of the inferred type argument. 
So, if the type variable contains a shape bound, the candidate list contains only this type, and other bounds are used to check if the candidate doesn’t contradict the collected bounds. 
There are two notes regarding this step. 
If there is a shape bound, it doesn’t contain any unfixed type variables because of the condition in the second phase. 
Hence, it will be a valid type argument. It can happen that some bounds will contain unfixed type variables. 
In this case, these bounds are removed from the checking and candidates set.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Fix(TypeVariable x):
  $U_{candidates}$ = 
  if ($B_{shape}$[x.idx] != null)
    setOf($B_{shape}$[x.idx])
  else
    ($B_{lower}$[x.idx] + $B_{upper}$[x.idx] + $B_{exact}$[x.idx]).filter(b $\rightarrow$
        !b.containsUnfixedTypeVariable
    )
  /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Fixing of type variables}
\label{img55::mainTypeInference3}
\end{figure}
\par
\begin{obs}
The last observation is to ensure that the propagation will end.
Since the algorithm doesn't add the same bound multiple times, the cycle can't occur.
\end{obs}

\section{Partial constructor type inference}

Constructor type inference, which will be a core part of the second part of the improvement, was mentioned in the discussion \cite{online:CtorTInf}. 
The design of the partial type inference regarding underscore placeholders will be used again in order to be coherent with method type inference. 
Problems regarding using generic aliases, default type parameters, or named type parameters persist, so either constructor type inference will not be based on them. 
However, since the inference is not limited by introducing breaking changes because there is no type inference at all, the type inference can be stronger. 
The stronger type inference regards target-typed inference, which will be useful because object creation is usually associated with assigning it to a target. 
It will also employ type inference based on type constraints, which will provide a wider context for type inference. 
Besides this functionality, the text will mention two additional features that will extend the context of type inference and will make the syntax less boilerplate, although they are controversial for \ac{LDT}. 
For this reason, the features will be presented as a voluntary extension that can be removed from the core design. 
The first feature will regard using type information from initializers, which would be valuable when creating collections or objects with object initializer syntax. 
The second feature will use the diamond operator to turn on the constructor type inference in cases when the compiler can surely determine the referring generic type without knowledge about the arity.

\subsection{Syntax}

The syntax is similar to partial method type inference.
Figure \ref{img56:constructorTypeInferenceExample} shows a simple usage where the underscore representes the inferred type argument.
This argument is deduced using a type received from the \texttt{t} variable declarations which determines the \texttt{int} type to be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
List<int> t = new List<_>();
\end{lstlisting}
\caption{Syntax of constructor type inference.}
\label{img56:constructorTypeInferenceExample}
\end{figure}
\par
Similar to the partial method type inferece, the \texttt{?} nullability operator is allowed to determine the type nullability.

\subsection{Class lookup}

Class lookup is done in the same way as in partial method type inference. 
The binding of the underscore identifier is skipped. 
The placeholder represents an inferred type, which has to be resolved during type inference. 
The inferred arguments are allowed only in an argument list of the type containing the called constructor.
So, if there is a generic type containing a nested class that is being created, the type arguments of the generic class have to be provided. 
This limitation is shown in Figure \ref{img59:TypeArgList}, where the first statement is invalid since it contains inferred type arguments in the \texttt{GenericWrapper} identifier, which doesn’t contain the called constructor. 
However, the second statement is valid because inferred type arguments are only in the \texttt{CreatingClass} identifier, which contains the called constructor.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new GenericWrapper<_>.CreatingClass<_>(arg1,...); // Not allowed
new GenericWrapper<int>.CreatingClass<_>(arg1,...); // Allowed
\end{lstlisting}
\caption{Allowed inferred type arguments.}
\label{img59:TypeArgList}
\end{figure}

\subsection{Argument binding}

The mentioned target-typed inference complicates the binding of the arguments. 
When a target is an assigned variable or a return statement, the type of the target is given by the declaration of the variable or method’s return type. 
However, when the target is an argument of the other method, the type doesn’t have to be known yet if the method is generic. 
Figure \ref{img60:target} shows a scenario when, at the time of binding the \texttt{Foo} creation expression, the target type is unknown because the binding order is from the methods’ arguments to the method call. 
Without the target type, \texttt{Foo}'s type argument can’t be inferred. 
The \texttt{Bar} creation expression should be bound first, which would infer the type of the first parameter, which could be used as a target type of the \texttt{Foo} creation expression.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<_>(Foo<_>(), 1);

class Bar<T>{
    public Bar(Foo<T> arg1, T arg2){}
}
class Foo<T>{}
\end{lstlisting}
\caption{Target as an argument.}
\label{img60:target}
\end{figure}
\par
This process was mentioned regarding the target-typed \texttt{new()} operator. 
Roslyn solves the operator in the following way. The operator is bound as an unconverted bound element which needs to be converted in the future. 
When the right overload of the method is chosen, Roslyn has to generate the necessary conversions of these arguments, which don't have an identical type as the corresponding parameter. 
At that time, the operator is converted by using an already-known target type. 
The result of the conversion is the binding of the creation expression, which type is the target type, and arguments are contained in the type operator’s argument list.
\par
The improvement is inspired by that. 
When there is an object creation expression as an argument, and the constructor type inference fails, a similar unconverted bound element is created. 
After the overload resolution, when the types of parameters are known, and the necessary conversion is started to be created, the object creation expression is tried to be bound again with the already known target type. 
However, the compiler has to be careful here. 
It has to try to bind the object creation expression without a target type only once to prevent exponential time of binding.
\par
Figure \ref{img61:exp} shows a scenario where if the compiler does not do that, it will cause an exponential time of binding the expression. 
Since the constructor of the \texttt{Bar} type is overloaded, the overload resolution has to check these two overloads. 
Each of these checks includes binding of arguments, type inference, and checking of the applicability of bound arguments on the inferred constructor. 
Since the binding of arguments contains binding of the similar object creation expression, it will make the
same overload resolution containing all overloads of the constructor. 
The target type can’t be provided here because the type argument is still unknown. 
When the binding of this argument is unsuccessful, the argument will be represented as an unconverted bound element and will be bound later after the resolution. 
This failure will happen for each overload resolution, which wastes time because it does the same computation multiple times. 
After the outer object creation expression is inferred using the type of the second argument, it will convert the inner object creation expression by providing the target type, which will resolve the valid object creation. 
This repeating failure is not a problem for the \texttt{new()} operator since it is cheap to express it automatically as an unconverted bound expression. 
However, the following observation offers a way to avoid it. 
If the argument can’t be bound without the target type in checking one overload, it also can’t be bound without the target type in the other overloads. 
So, the improvement remembers if the argument containing the object creation expression was already bound without the target type and failed. 
If this is true, it automatically skips the binding and returns an unconverted bound element, which will prevent obvious failure and save time.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<_>(new Bar<_>(null, null), 1);

class Bar<T>{
    public Bar(Foo<T> arg1, T arg2){}
    public Bar(Foo<T> arg1, List<T> arg2){}
}
\end{lstlisting}
\caption{Potential exponential time of binding.}
\label{img61:exp}
\end{figure}

\subsection{Constructor type inference algorithm}

The previously mentioned algorithm for inferring method type arguments is unchanged except for collecting new bounds in the first phase of the algorithm. 
If a target type is provided, an upper bound type inference is made from it to the partially inferred type containing the constructor. 
If the inferring type contains \texttt{where} clause containing type parameter constraints, for each of the type constraints which represented either inheritance constraints or interface implementation constraints is performed lower bound type inference from it to the corresponding type parameter.
\par
Figure \ref{img62:ctro} shows an example of constructor type inference, where both of the type arguments of the \texttt{Bar} type are inferred. 
The algorithm will contain four type variables. 
The first two variables represent type arguments, and the second two variables represent the underscores.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IBar<int> t = Bar<_, _>();


interface IBar<T> {}

class Bar<T1, T2> : IBar<T1> where T2 : object {}
\end{lstlisting}
\caption{Example of type inferences.}
\label{img62:ctro}
\end{figure}
In the first phase, lower bound type inference is made from the \texttt{IBar<int>} type to the \texttt{Bar<\_,\_>} type, which will yield in the \texttt{int} lower bound of the type variable representing the first underscore. 
Then, the type constraint of \texttt{T2} type parameters causes another lower bound type inference from the \texttt{object} type to the type variable representing the \texttt{T2} type parameter. 
Shape inferences continue to relate type variables representing underscores with type variables representing type parameters. 
Then, the fixation is made, and it results in \texttt{Bar<int, object>} inferred type.

\subsection{Initiliazers extension} \label{sect12:ex1}

Initializers can be part of the creating expression, which will allow us to use it as another source of type information. 
As the thesis mentions in the previous chapter, initializers are syntax sugar. 
In the case of an object initializer, it represents a field assignment. 
If the field declaration contains a type parameter, the type of initializer element can be used to deduce the type parameter. 
Figure \ref{img58:initializer} shows an example of an initializer when the \texttt{Bar}’s type argument \texttt{int} can be deduced using type information from the initializer. 
Since the \texttt{Field} declaration type is the \texttt{T} type parameter and the \texttt{int} value is assigned to that field in the initializer, the compiler can deduce that the type argument is \texttt{int}. 
The improvement allows this inference by performing lower bound type inference for each item in the initializer. 
The inference is made from the type of assigning expression to the type of the field’s type declaration.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<int>{ Field = 1 };

class Bar<T> {
    public T Field;
}
\end{lstlisting}
\caption{Object initializer.}
\label{img58:initializer}
\end{figure}
\par
A similar deduction can be made with array initializers where the element’s type is inferred.
The improvement will allow it by performing lower bound type inference for each item in the initializer. 
The inference is made from the type of assigning expression to the inferred type of array’s element.
\par
However, collection initializers have been shown to be a little tricky. 
Since it is a syntactical sugar for calling the special \texttt{Add} method for each element, the method can be overloaded. 
The previous section regarding Hindley-Millner type inference mentions that overloading can cause an exponential time of the type inference computation because it has to reason about each overload separately from the rest of the inferred bounds. 
To prevent slow compilation because of this issue, the improvement will allow the use of the information for the initializers in the case where the \texttt{Add} method is not overloaded. 
This limitation seems to be reasonable since a lot of collections from the standard library don’t overload the method. 
When there is no overload, the issue with time complexity disappears. 
When the condition above is true, the first phase of the type inference algorithm additionally makes the lower bound inference for each item in the initializer. 
The inference is made from the type of the expression to the type of method parameter.
\par
The last initializer regards indexers.
Since indexers can be considered as a special case of methods that can be overloaded as well, the same process is made.

\subsection{Diamond operator extension} \label{sect13:ex2}

Since constructor type inference is invoked when the creating type contains inferred type arguments in its type argument list, it can feel like a boilerplate when all type arguments are inferable. 
Figure \ref{img57:diamondExample} shows an example of creating the \texttt{Dictionary} generic type whose all type arguments can be inferred using the target type. 
Although C\# allows the definition of generic types with the same name and different arity, it is not very common. 
The standard library doesn’t contain another type of \texttt{Dictionary} with a different arity, so specifying the arity in the example is redundant in this case.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IDictionary<int, string> t = new Dictionary<_,_>();
\end{lstlisting}
\caption{Reduncant specification of arity.}
\label{img57:diamondExample}
\end{figure}
\par
For these use cases, where the compiler can confidently choose a generic type without looking at the arity, the diamond operator can be used to turn on the type inference. 
Figure \ref{img58:diamondExample2} shows the usage of the diamond operator with the \texttt{Dictionary} type. 
Supposing that in the rest of the program, there is no other definition of \texttt{Dictionary} type with a different arity, the compiler can assume that the referring type is the \texttt{Dictionary} type from the standard library.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IDictionary<int, string> t = new Dictionary<>();
\end{lstlisting}
\caption{Diamond operator.}
\label{img58:diamondExample2}
\end{figure}

\section{Partial time inferece during dynamic member invocation} \label{sect11:dynamic}

The previous chapter mentioned that despite the dynamic binding, the compiler can still check an expression containing the dynamic value. 
The compiler checks three relevant expressions containing the dynamic value as an argument. 
It is a static method invocation, instance method invocation whose receiver is not a dynamic value, and object creation expression. 
For each candidate of this kind, a modified parameter list and argument list are created to be checked. 
If there is no candidate for which the test succeeded, a compile-time error occurs.
\par
The modified parameter list is created in the following way. 
If the candidate is a generic method and type arguments were provided, it substitutes them in the parameter list. 
Then, all parameters that include a type parameter are elided with corresponding arguments. 
The resulting set of parameters and arguments are checked.
\par
The improvement adjusts the modified parameter list of partially inferred methods by substituting only these type arguments, which don’t contain any inferred type arguments. 
The same process is made in object creation expression, where the substitution is made on the type containing the constructor candidate.
\par
For practical reasons, it also announces a warning about using partial inference in late-binding, which doesn’t support it since it is handled by the runtime. 
However, there are situations where the runtime is able to infer type arguments even without partially hinting. 
Figure \ref{img63:dinamic} shows an example where the \texttt{Foo} method is inferred by runtime because inferred type arguments are inferrable in the runtime. 
These situations are valid, and hence, the compiler should just warn about them.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
dynamic t = ...;
Foo<_, _>(t, 1);

void Foo<T>(T arg1, T arg2) {}
\end{lstlisting}
\caption{Runtime type inference.}
\label{img63:dinamic}
\end{figure}

\section{Other type inference improvements}

Besides the proposed improvement described above, the work touched on surrounding areas of type inference during the initial problem exploration. 
The chapter gives a couple of thoughts about touched areas since they were also investigated and can be a future extension of the C\# programming language.

\subsection{Shared type inference context}

C\# currently has a local type inference preventing advanced type inferences. 
The next big improvement of the type inference would be to provide global type inference using inferring contexts similar to Rust's. 
However, since it would bring a breaking change, it would require an additional tool that would patch the old code to work in the same way compiled with the new type inference. 
However, this refactoring can be challenging, so at least it should warn the user about possible behavior changes in each place where it can occur.

\subsection{Inferring return value of methods}

The work already mentioned the possibility of inferring the return value type of the method, which can be beneficial for writing a simple method whose name indicates the return value, helping a reader to understand the code. 
An example of the function can be \texttt{ToString}, which indicates that the return value is the \texttt{string} type.
\par
This language feature can be seen in the Kotlin programming language, which allows the definition of a method without a return type if the method is exactly one expression. 
The Kotlin language is a strongly typed language developed by JetBrains. 
Kotlin’s main target is JVM, and its goal is to be an alternative to Java with excellent interoperability between these languages to use them almost interchangeably in one project. 
Because of that, it has a similar type system as Java, which is not far away from C\#. 
Figure \ref{img64:kotlin} shows an example of the \texttt{MyClass} definition containing the \texttt{toMyString} method definition. 
The signature consists of the \texttt{fun} keyword, the name, and the equal sign followed by one expression. 
The method's return type is inferred based on the expression's return value.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class MyClass {
    fun toMyString() = "TEXT"
}
\end{lstlisting}
\caption{Kotlin return type inference.}
\label{img64:kotlin}
\end{figure}
\par
The main obstacle regarding inferred return type in the method's signatures is an order of compilation and possible multithreaded compilation.
The Roslyn compiler first finds all definitions in the program, which allows it to compile methods separately in different threads.
This advantage is because the method's content consists of only types and methods defined in the program, whose signatures are already known thanks to the previous phase.
So, the compiler knows the exact return types of the used functions, which allows it to do a type check.
\par
Kotlin divides the method compilation into two groups, as it is described in the video \cite{online:kotlinCompiler}. 
The first group contains methods without a return type, which is compiled first in a single thread. 
This will allow us to obtain all signatures for the methods in the program. 
Obviously, if these methods are recursions, the compiler can’t infer the return type, and an error occurs.
The second group contains methods with a return type, which can be compiled in multiple threads since all method signatures are already known.
\par
Although this implementation would be possible in Roslyn as well, it would require a large number of changes. 
Instead of that, C\# could allow inferring return in a local function, which is a function defined inside a method body and can be used only inside the method. 
There are two benefits of this. 
The main architecture of the Roslyn compiler doesn’t have to be changed since the method is compiled by one thread, and the local functions can’t be used outside. 
Local functions are usually tied with the method implementation, and the return type is not contained in public API, so a reader shouldn’t need to know the return type till the time when he/she wants to explore the inner implementation, which gives him/her a context to deduce the return type.


