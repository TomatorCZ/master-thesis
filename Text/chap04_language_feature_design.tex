\chapter{Language Feature Design} \label{sect09:lang}

The previous chapter determined two improvement directions that would be beneficial to explore. 
This chapter continues with exploring these directions consisting of the partial method type inference and the constructor type inference. 
The goal of this exploration is to precisely design the improvements that are used afterward as the content of the mentioned proposal for \ac{LDM} and implemented in Roslyn.
\par
We take the language change suggestions, mentioned in the GitHub Issues section \ref{sect04:github}, as an inspiration for the improvements and divide them into three following groups.
Suggestions in the first group, given below, regard improving the method type inference algorithm and are used in the constructor type inference mentioned later.
\begin{enumerate}
  \item \textit{Target-typed inference} mentioned in Section \ref{sect06:targetType}
  \item \textit{Type inference based on constraints} mentioned in Section \ref{sect11:is6}
\end{enumerate}
The following second group consists of suggestions describing general partial type inference which relate to both improvements.
\begin{enumerate}
  \item \textit{Default type parameters} mentioned in Section \ref{sect07:is1}
  \item \textit{Generic aliases} mentioned in Section \ref{sect08:is2}
  \item \textit{Named type parameters} mentioned in Section \ref{sect09:is3}
  \item \textit{Inferred type argument} mentioned in Section \ref{sect10:is4}
  \item \textit{Relocation} mentioned in Section \ref{sect13:is8}
\end{enumerate}
The third group contains suggestions introducing type inference in new C\# constructs. 
The first suggestion describes the second improvement which is explored further and the second suggestion is mentioned in the last section of this chapter as a potential future improvement that will be difficult to implement and which is not in the scope of this work.
\begin{enumerate}
  \item \textit{Constructor type inference} mentioned in Section \ref{sect14:is9}
  \item \textit{Inferred method return type} mentioned in Section \ref{sect12:is7}
\end{enumerate}

\section{Partial Method Type Inference}

The partial method type inference occurs in the second group where various techniques are used to allow specify only some type arguments in the generic method call.
These techniques are discussed below.
\par
The disadvantage of \textit{default type parameters} \ref{sect07:is1} is that it requires to provide the defaults in the type parameter declarations.
It is problematic since the old code has to be changed to allow skipping the type arguments which have defaults.
For this reason, the work excludes this suggestion.
\par
\textit{Generic aliases} \ref{sect08:is2} don't work for methods.
There could be something like a generic alias for a method using a similar syntax as for the type which would allow to give defaults for some type parameters.
However, it would still need additional declarations to provide these aliases and we don't think that it is flexible enough since it requires a new declaration for each method call scenario, where is beneficial to omit a type argument.
\par
\textit{Named type parameters} \ref{sect09:is3} are excluded since providing that would be an uncommon new feature that has no equivalent in other well-known languages like Java, C++, Kotlin, and Rust. 
We believe it would be confusing to introduce it to the users since it is a controversial change.
\par
The suggestion of representing \textit{inferred type arguments} \ref{sect10:is4} looks promising.
It is already used in different languages, like a star symbol in Kolin and Java or an underscore in Rust and F\#. 
So, it is more common and intentional than other mentioned suggestions. 
It introduces no or at least minimal syntax changes into the language, which makes the usage simple, and it solves the problem of specifying all type arguments.
This suggestion is a core of the partial method type inference improvement.
\par
\textit{Relocation} \ref{sect13:is8} doesn’t solve the problem of specifying all type arguments. 
It just compacts type argument lists into one.

\subsection{Syntax}

The syntax has to be chosen to allow a user to represent type arguments that have to be inferred by the compiler.
The choice of the syntax should be based on the following conditions:
\begin{enumerate}
  \item The usage should be intuitive for a user
  \item A future extension of type inference should reuse the syntax
  \item It shouldn't introduce the breaking change
\end{enumerate}
We identified five use cases that use the syntax in different situations to help reasoning about advantages and disadvantages of different syntax alternatives which are presented in the mentioned GitHub issues.
Table \ref{table2:useCasesChar} shows the use cases and their examples in the current C\# language version.
\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | } 
  \hline
  Use case & Example\\
  \hline
  Type argumens of generic method & \texttt{Foo<Type1, ...>(...)}\\
  \hline
  Type arguments of generic type & \texttt{new Bar<Type1, ...>(...)}\\
  \hline
  Variable declaration & \texttt{int temp = ...}\\
  \hline
  Array type & \texttt{int[]}\\
  \hline
  Nullable type & \texttt{int?}\\
  \hline
\end{tabular}
\end{center}
\caption{Use cases helping to choose the syntax.}
\label{table2:useCasesChar}
\end{table}
\par
\textbf{Type argumens of generic method} use case represents a situation where a user wants to skip type arguments which can be inferred by the compiler and wants to specify just the ambiguous type arguments.
\par
\textbf{Type arguments of generic type} use case represents a situation where a user wants to infer either all type arguments of the generic type or to specify ambiguous type arguments and let the compiler infer the rest. 
The syntax doesn’t have to be bound to the shown object creation expression example, but it can be also used on other potential places like a variable declaration, type casting, or a type argument of a generic method. 
The description of the syntax behavior in other places than an object creation expression and a generic method call is not in the scope of this work. 
However, the syntax is considered since it is a natural future continuation to use type inference on new places in the language.
\par
\textbf{Variable declaration} use case represents a situation where a user wants to infer a type of variable that is declared. 
This use case already has the \texttt{var} syntax and reminds the secondary ability of the \texttt{var} keyword representing an inferred type of the declared variable. 
Because of that, the new syntax shouldn’t be allowed to be used in this situation.
\par
\textbf{Array type} use case represents a situation where a user should be able to use the syntax to represent an array type whose element type should be inferred by the compiler.
\par
\textbf{Nullable type} use case represents a situation where a user should be able to hint to the compiler a nullability of a type that should be inferred.
\par

\subsubsection{Diamond Operator} 

The diamond operator syntax consists of a pair of two angle brackets \texttt{<>}.
\par
In the context of the first use case, the syntax is used after the generic method name instead of the type argument list.
The semantics of the operator is to determine that the method name is generic so the compiler will consider only generic methods during overload resolution.
Figure \ref{img40:opDi1} shows an example of the syntax used in the \texttt{Foo} method call.
Since it doesn't allow to skip inferable type arguments, we don't see it as a good candidate for the feature.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo<>(arg1, ...);
\end{lstlisting}
\caption{Type argumens of generic method use case.}
\label{img40:opDi1}
\end{figure}
\par
In the context of the second use case, the syntax is used after the generic type name instead of the type argument list.
The semantics of the operator is to determine that the type is generic so the compiler will look up only generic types.
Figure \ref{img41a:opDi2} shows the usage in the object creation expression where the type arguments of the \texttt{Bar} type should be inferred by the compiler.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
class Bar { ... }
class Bar<T1> { ... }
class Bar<T1, T2> { ... }
...
new Bar<>(...);
\end{lstlisting}
\caption{Type arguments of generic type -- ambiguity.}
\label{img41a:opDi2}
\end{figure}
As we can notice, it is not clear, where the compiler should find constructors for overload resolution since the \texttt{Bar<>} syntax can represent multiple types differing in type parameter's arity.
Probing all options for the constructors seems complicated because it requires a significant change in the Roslyn implementation and it will influence the compile time because of the increased overloading resolution complexity. 
\par
On the other hand, it is common to have just one type without multiple variations of type parameter's arity in the current name scope.
Figure \ref{img41b:opDi2} shows an example where an object representing a directory is created.
The compiler can check if there is just one generic type with this name in the current scope.
If it is, the problem with ambiguity disappears and the compiler can try to infer the type arguments.
We think that it is a beneficial usage since it allows to turn on type inference of object creation expression.
Extending the current overload resolution during object creation expression binding to consider generic types when the type doesn't contain the type argument list can't be used instead of it since it would cause a breaking change.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
new Directory<>(...);
\end{lstlisting}
\caption{Diamond operator -- object creation expression.}
\label{img41b:opDi2}
\end{figure}
The syntax can be used in other places too, however, we don't see any practical usage for that.
\par
The third use case is not considered since there is already the \texttt{var} keyword.
\par
In the context of the fourth use case, the syntax determines that a user wants to infer an element of an array.
Figure \ref{img43:opDi4} shows an example, where there is the \texttt{temp} variable declaration of the array type whose element should be inferred.
We think, that the meaning of this syntax is not clear to a user in comparison to the previous use case where it reminds the type argument list.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
<>[] temp = ...
\end{lstlisting}
\caption{Diamond operator -- array type.}
\label{img43:opDi4}
\end{figure}
\par
In the context of the fifth use case, the syntax should represent a nullable type which is inferred by the compiler.
Figure \ref{img44:opDi5} shows an example, where a user wants to infer the type of the declared \texttt{temp} variable and hints to the compiler the nullability of that type.
We don't think that the usage is intuitive for that and we exclude it.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
<>? temp = ...
\end{lstlisting}
\caption{Diamond operator -- inferred nullable type.}
\label{img44:opDi5}
\end{figure}
\par
We think that the diamond operator would be beneficial only in the second use case where it turns on the type inference of object creation expression.
The symbol already means a generic type with one type argument in the \texttt{typeof(Bar<>)} expression which has a conflict with the new semantics in the context of object creation expression.
However, we think that the context of reflection and object creation expression are distinct enough to use the symbol for a different meaning as we can see in other language constructs.
We think that the advantage of the syntax in this use case is that it still reminds the type argument list and it is not verbose.

\subsubsection{Nothing Separated by Commas} 

In the context of the first use case, the syntax omits type arguments that should be inferred by the compiler and specifies just ambiguous type arguments using commas as a separator. 
Figure \ref{img45:opW1} shows an example where the syntax is used to call the \texttt{Foo} method with three type arguments. 
The first and third type argument are inferred by the compiler and the second type argument is specified by a user as the \texttt{int} type.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<, int,>(arg1, ...);
\end{lstlisting}
\caption{Whitespace -- generic method call.}
\label{img45:opW1}
\end{figure}
There are the following advantages of this syntax. 
It determines the arity of the called generic method. 
The syntax is already used in the \texttt{typeof()} operator where commas are used to determine the arity of the reflected type. 
It allows specifying just ambiguous types. 
Although the syntax is a good candidate, we think that skipping the type arguments by nothing makes the code comprehension of the code worse since it makes it difficult to determine the position of the type arguments at first sight.
\par
The syntax has the same use and meaning in the second use case.
\par
In the context of the fourth use case, the syntax omits the type of a array. 
Figure \ref{img46:opW4} shows the syntax where the first statement means a declaration of the \texttt{temp} variable which has a type of array whose element is inferred by the compiler. 
The second statement uses the syntax to hint to the compiler that the second type argument should be an array type.
We think that the usage in this use case is unintuitive.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
[] temp = ...
Foo<,[],>(arg1, ...);
\end{lstlisting}
\caption{Whitespace -- array type.}
\label{img46:opW4}
\end{figure}
\par
In the fifth use case, the syntax makes it difficult to append the \texttt{?} mark since it doesn't have any placeholder.
There is the same problem as mentioned above.
\par
Although the syntax is a good candidate in the first and second use cases, it is not suitable for the array types and nullable types.
We consider this disadvantage important and exclude the syntax.

\subsubsection{Underscores Separated by Commas} 

The syntax uses an underscore to represent a type that has to be inferred by the compiler. 
The syntax is commonly used in other programming languages like F\# or Haskell to represent inferred type arguments which is considered as an advantage. 
Although it has different semantics in C\# where it can also mean a discarded variable.
We don’t think it makes the usage of that unintuitive or confusing in the following use cases.
\par
The usage of the syntax in the first use case is similar to the previous syntax where omitting the type arguments is done by using the underscore.
Figure \ref{img50:opU0} shows the same \texttt{Foo} method using underscores to represent the first and third type argument as an inferred argument.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_, int, _>(arg1, ...);
\end{lstlisting}
\caption{Underscore -- generic method.}
\label{img50:opU0}
\end{figure}
We think that the underscore placeholder helps to identify type argument positions in comparison with the previous syntax variant.
\par
The syntax has the same use and meaning in the second use case.
\par
In the context of the fourth use case, the syntax seems to be more intuitive than in the previous syntax variant.
Figure \ref{img51:opU4} shows the declaration of the \texttt{temp} variable whose type is an array with the inferred element's type.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_[] temp = ...
\end{lstlisting}
\caption{Underscore -- array type.}
\label{img51:opU4}
\end{figure}
\par
The fifth use case is shown in Figure \ref{img52:opU5} where it uses the \texttt{\_?} syntax to express that the inferred type of the temp variable has to be nullable.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_? temp = ...
\end{lstlisting}
\caption{Underscore -- nullable.}
\label{img52:opU5}
\end{figure}
\par
A disadvantage is the introduction of breaking change because C\# allows the underscore as a type identifier. 
However, we don't think that it is a blocker since a similar change was done with the discards and the potential change behavior is
easily discoverable.

\subsubsection{\texttt{var} Keywords Separated by Commas} 

The \texttt{var} keyword representing the placeholder is another natural option of the syntax.
The usage and meaning of the syntax is similar to the previous syntax variant except for replacing the underscore with the \texttt{var} keyword.
An advantage is the already used \texttt{var} keyword in a variable declaration where the secondary meaning of it is that it represents an inferred type.
On the other hand, it also means that a variable declaration which can be confusing.
Another disadvantage is the syntax size which seems to be too long for this purpose.
We exclude this variant based on these several issues. 

\subsubsection{Something Else Separated by Commas} 

A different placeholder for the inferred type arguments doesn't make a lot of sense because we think that it would be less intuitive than already mentioned syntax variants.

\subsubsection{Conlusion} 

The thesis chooses the underscore as a placeholder for the inferred type argument since the meaning of this character is related to the intention. 
It also seems to be the shortest and synoptical way to skip inferred type arguments. 
The possible breaking change is not an obstacle in this situation since a similar decision was made for the \texttt{var} keyword, and the situation where it can occur seems to be rare. 
Problems with the potential future extension where the underscore can represent inferred type in the variable declaration would be prohibited to not mix it with the \texttt{var} keyword. 
Although the diamond operator is not very useful in a generic method call, it makes sense in an object creation expression. 
The potential usage and analysis of that is covered later in this work.

\subsection{Method and Typename Lookup}

The previous section presented the proposed syntax for skipping inferred type arguments using an underscore as a placeholder. 
This section continues with determining what the expression containing the syntax means for the compiler.
\par
Since an underscore character is a valid type identifier in C\# and there is
1:1 mapping of inferred type arguments to these placeholders, determining the referred generic method containing the proposed syntax is almost unchanged. 
A change is in the overload resolution where if the generic method is \textit{partially inferred}, meaning it contains the syntax, the type inference has to be done to determine the type arguments of that method.
\par
An underscore can be represent a nullable or non-nullable type. 
If the inferred type argument has to be a nullable type, the metioned \texttt{?} operator can be appended to the underscore. 
Figure \ref{img53:null} shows an example of using the nullable operator. 
The call of the \texttt{Foo} generic method has three type arguments where the first is inferred by the compiler and which has to be nullable. 
The second type argument is the \texttt{List<\_>} type, containing an inferred nullable type argument as well. 
The third type argument doesn’t require the nullable type, so the inferred type can be either nullable or non-nullable.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_?, List<_?>, _>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Inferring nullable type argument.}
\label{img53:null}
\end{figure}
\par
The typename lookup is almost unchanged. 
If there is an underscore referring to an inferred type argument, it simply ignores the binding of this identifier.
\par
The underscores contained in the type arguments are handled in the changed method type inference algorithm mentioned in the following section.

\section{Method Type Inference Algorithm Change}

The thesis extends the method type inference by introducing new type variables, which represents inferred type arguments contained in the type argument list. 
Firstly, if a generic method call doesn’t contain a type argument list, the method type inference is unchanged. The change is when the generic method is partially inferred. 
Figure \ref{img54:partInf} shows an example of a partially inferred method \texttt{Foo} containing two type parameters. 
The former algorithm identifies the type arguments as type variables for which it tries to find a unique type. 
The algorithm can be extended to represent placeholders for inferred type arguments as type variables, too. 
Using the example, all three underscores would be represented as three unique type variables besides those representing \texttt{T1} and \texttt{T2} type parameters. 
However, this extension also has to be respected by the order of type variables fixing and inferring. 
A reason can be seen in the \texttt{T2} type variable. 
The \texttt{Dictionary<\_, \_>} is considered as a bound for the type variable, which has to be respected. 
However, this bound contains other type variables which doesn't have to be known yet. 
So, the algorithm has to first fix the type variables contained in that bound and then infer the \texttt{T2} type variable. 
The second observation for this extension is a way of collecting the bounds. 
Since type variable bounds can contain other type variables, it is necessary to propagate the relation between the bounds at the time of adding new bounds. 
An example of this can be demonstrated using the given Figure \ref{img54:partInf}. 
The \texttt{Dictionary<\_, \_>} is a bound of the \texttt{T2} type variable. 
Its second bound is a type of the \texttt{p2} argument. 
This type gives us bounds for type variables contained in the \texttt{Dictionary<\_, \_>} bound, which have to be propagated.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_, Dictionary<_, _>>(arg1, new Dictionary<int, int>());

void Foo<T1, T2>(T1 p1, T2 p2)
\end{lstlisting}
\caption{Partially inferred method call.}
\label{img54:partInf}
\end{figure}

\subsection{New Definitions}

The proposed algorithm uses three new definitions which are given below.
\begin{defn}[Inferred type argument]
Inferred type argument is a type argument which is inferred by the compiler and is represented as the \texttt{\_} symbol in a type argument list.
\end{defn}
\begin{defn}[Shape dependence]
An unfixed type variable \texttt{$X_i$} \emph{shape-depends directly on} an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} represents \textit{inferred\_type\_argument} and \texttt{$X_e$} is contained in shape bound of the type variable \texttt{$X_i$}.
\texttt{$X_i$} \emph{shape-depends on} \texttt{$X_e$} if \texttt{$X_i$} \emph{shape-depends directly on} \texttt{$X_e$} or if \texttt{$X_i$} \emph{shape-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \emph{shape-depends on} \texttt{$X_e$}. Thus \emph{shape-depends on} is the transitive but not reflexive closure of \emph{shape-depends directly on}.
\end{defn}
\begin{defn}[Type dependence]
An unfixed type variable \texttt{$X_i$} \emph{type-depends directly on} an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} occurs in any bound of type variable \texttt{$X_i$}.
\texttt{$X_i$} \emph{type-depends on} \texttt{$X_e$} if \texttt{$X_i$} \emph{type-depends directly on} \texttt{$X_e$} or if \texttt{$X_i$} \emph{type-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \emph{type-depends on} \texttt{$X_e$}. 
Thus \emph{type-depends on} is the transitive but not reflexive closure of \emph{type-depends directly on}.
\end{defn}

\subsection{Algorithm Phases}

The required change of the algorithm is presented as an algorithm divided into three sections, which is based on the former method type inference. 
Figure \ref{img54:mainTypeInference1} shows the beginning, the first, and second phases. 
The first step is to identify all type variables, which would be an objective of the type inference. 
This is done by the \texttt{getAllTypeVariables} function, which replaces the underscore placeholders in the provided type arguments (If the type arguments were provided) with new type variables and joins them with type variables representing type parameters of
the method.
Besides the already known three types of bound, the algorithm adds \textit{shape-bound} representing a type argument given in the type argument list.
\par
The reason for a new type of bound is the following. 
When a user provides the type argument, the algorithm should infer the exact same type. 
None of the already introduced type bounds offers this feature. 
An example of this need is described by a potential scenario when there is the \texttt{string?} type as a type argument. 
When the compiler treats nullability, it should infer the nullable type(not \texttt{string}). 
Imagine that the provided type argument would be added as an exact bound.
It can happen that the type variable will contain another exact bound, which will be the non-nullable version of the type.
The current implementation will infer the \texttt{string} type although it should fail since these types are not equivalent in nullable-aware code.
The behavior of the exact bound can’t be changed because of breaking changes, so we have to add a new bound to reflect this need.
\par
\texttt{FirstPhase} collects shape bounds from the provided type argument list before the initial  collection of bounds from the argument list.
The referring\\ \texttt{InferShapeBound} is described later with the rest of inferring methods.
\par
\texttt{SecondPhase} now respects newly added dependencies, which forces to infer type variables in the correct order. 
If there are no type variables that are independent, the algorithm relaxes the condition for type variable fixation to break the possible circular dependency, which still has a chance to be resolved. 
In comparison to the former algorithm, the relaxation still has to respect \textit{shape-depends on} relation. 
The reason for that is to prohibit inferred type from being different from the provided ``shape'' in the type argument list. 
Additionally to allow type variable fixing, at least one bound mustn't not contain an unfixed type variable. 
This requirement ensures at least one type candidate, which can be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
Input: method call M<$S_1$,...$S_n$>($E_1$,...$E_x$) and 
       its signature $T_e$ M<$X_1$,...,$X_n$>($T_1$ $p_1$,...,$T_x$ $p_x$)
Output: inferred $X_1$,...$X_n$,...$X_{n+l}$
$B_{lower}$ = $B_{upper}$ = $B_{exact}$ = $B_{shape} = $F = []
$TV$ = getAllTypeVariables(X, S)
FirstPhase()
SecondPhase()
fn FirstPhase():
  S.foreach(s -> InferShapeBound(s, T[s.idx]))
  /*Continuation as the former method type inference*/
fn SecondPhase():
  while (true):
    $TV_{indep}$ = $TV$.filter(x $\rightarrow$ 
      F[x.idx] == null && $TV$.any(x $\rightarrow$ 
        dependsOn(x, y) && shapeDependsOn(x, y) 
        && typeDependsOn(x, y)
      )
    )
    $TV_{dep}$ = $TV$.filter(x $\rightarrow$
      F[x.idx] == null && $TV$.any(y $\rightarrow$ 
        (dependsOn(y, x) || shapeDependsOn(y, x) 
          || typeDependsOn(y, x)) 
        && !$TV$.any(t $\rightarrow$ shapeDependsOn(x, t))
        && ($B_{lower}$+$B_{upper}$+$B_{exact}$+$B_{shape}$).any(b $\rightarrow$ 
            !b.containsUnfixedTypeVariable
        )
      )
    )
    /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Phases of new Method Type Inference}
\label{img54:mainTypeInference1}
\end{figure}

\newpage

\subsection{Collecting Type Bounds}

Figure \ref{img55:mainTypeInference2} shows three adjusted inferences, adding new bounds, and presents a new \texttt{InferShape} inference.
The change is in propagating nested type bounds between type variable bounds. 
This is done by the \texttt{Propagate} function, which is invoked after a new bound is added. 
It iterates over all bounds of the type variable and makes additional type inferences for each bound containing an unfixed type variable checked by the \texttt{containsUnfixedTypeVariable} property. 
This step will ensure that the unfixed type variable will receive all bounds which are associated with it. 
Using mentioned example \ref{img54:partInf}, this phase propagates the  \texttt{int} type bounds contained in the \texttt{Dictionary<int, int>} type of the provided argument to the underscores representing type variables in the \texttt{Dictionary<\_ ,\_>} type argument.
Since the design of the algorithm always adds type bounds received from the left argument of algorithm's functions to the type variable obtained from the right argument of algorithm's functions, the inference has to be done for each transposition of the pair of the added bound and an already collected type variable bound.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Propagate(Type U, int typeVariable) {
  setOf($B_{shape}$[typeVariable],
    $B_{lower}$[typeVariable],
    $B_{upper}$[typeVariable],
    $B_{exact}$[typeVariable]
  ).foreach(b $\rightarrow$
    if (b.containsUnfixedTypeVariable) InferHelper(U, b)
    if (U.containsUnfixedTypeVariable) InferHelper(b, U)
  )
}

fn InferExact(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{exact}$[t.idx].contains(U)) {
    $B_{exact}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferLower(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{lower}$[t.idx].contains(U)) {
    $B_{lower}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferUpper(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{upper}$[t.idx].contains(U)) {
    $B_{upper}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferShape(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null)) {
    $B_{shape}$[t.idx] = U
    Propagate(U, t.idx)
  }
\end{lstlisting}
\caption{\textit{Exact inference}, \textit{Upper-bound inference}, \textit{Lower-bound inference}, \textit{Shape-bound inference}}
\label{img55:mainTypeInference2}
\end{figure}
\par
Table \ref{table3:InferHelper} shows which inference is called based on the \texttt{InferHelper}'s inputs. 
For example, if the \texttt{U} represents the added lower bound and \texttt{b} is an exact bound, the algorithm calls the \texttt{InferUpper} function. 
The intuition behind the table is to respect the relation between the bounds of the type variable.
So, for example, all bounds of lower bounds are lower bounds for exact, upper, and shape bounds of that type variable and are exact bounds for each other.
\begin{table}[h!]
\begin{center}
\begin{tabular}{ | c | c | c | c | c | } 
  \hline
   & Lower & Upper & Exact & Shape\\
  \hline
  Lower & InferExact  &  InferUpper & InferUpper & InferLower \\
  \hline
  Upper & InferLower  &  InferExact & InferLower & InferLower \\
  \hline
  Exact & InferLower  &  InferUpper & InferExact & InferExact \\
  \hline
  Shape & InferLower  &  InferUpper & InferExact & InfeExact \\
  \hline
\end{tabular}
\end{center}
\caption{Matrix of \texttt{InferHelper} function.}
\label{table3:InferHelper}
\end{table}

\subsection{Fixation}

Figure \ref{img55::mainTypeInference3} shows the last part of the changed algorithm, the type variable fixation. 
The set of candidates is changed to respect the shape-bound ability to express the exact form of the inferred type argument. 
So, if the type variable contains a shape bound, the candidate list contains only this type, and other bounds are used to check if the candidate doesn’t contradict the collected bounds. 
There are two notes regarding this step. 
If there is a shape bound, it doesn’t contain any unfixed type variables because of the condition in the second phase. 
Hence, it will be a valid type argument. It can happen that some bounds will contain unfixed type variables. 
In this case, these bounds are removed from the checking and candidates set.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Fix(TypeVariable x):
  $U_{candidates}$ = 
  if ($B_{shape}$[x.idx] != null)
    setOf($B_{shape}$[x.idx])
  else
    ($B_{lower}$[x.idx] + $B_{upper}$[x.idx] + $B_{exact}$[x.idx]).filter(b $\rightarrow$
        !b.containsUnfixedTypeVariable
    )
  /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Fixing of type variables}
\label{img55::mainTypeInference3}
\end{figure}
\par
\begin{obs}
We want to make sure that the propagation will end.
Since the algorithm doesn't add the same bound multiple times, the cycle can't occur.
\end{obs}

\section{Partial Constructor Type Inference}

The second improvement explored by the thesis is the \textit{constructor type inference} mentioned in the discussion \cite{online:CtorTInf}. 
In addition to the constructor type inference, we present partial constructor type inference using underscore placeholders to represent inferred type arguments in the same way as in the partial method type inference.
\par
Since the potential suggestions from GitHub issues can be applied to the partial constructor type inference, we discuss them again in relation to this improvement.
Problems regarding using \textit{default type parameters}, \textit{generic aliases}, \textit{named type parameters}, or \textit{relocation} mentioned in the partial method type inference persist, so either the partial constructor type inference is not based on them.
However, since the inference is not limited by introducing breaking changes because there is no type inference at all, the type inference can be stronger. 
The stronger type inference can be done by using \textit{target-typed inference} and \textit{type inference based on constraint} contained in the first group of divided issues presented in the introduction of this chapter.
Target-typed inference is useful because an object creation is usually associated with assigning it to a target. 
Type inference based on type constraints provides a wider context for type inference allowing to infer the type arguments based on \texttt{where} clauses in the type declaration of the created object. 
\par
Besides this functionality, the text mentions two additional features that extends the context of type inference and makes the syntax less boilerplate.
After a discussion with a member of \ac{LDT}, the additional features are considered to be controversial. 
For this reason, the features is presented as a voluntary extension that can be removed from the core design. 
The first feature regards using type information from initializers, which is valuable when creating collections or objects with the object initializer syntax. 
The second feature uses the diamond operator to turn on the constructor type inference in cases when the compiler can surely determine the referring generic type without knowledge about the arity.

\subsection{Syntax}

The choice of syntax is the same as in the partial method type inference.
Figure \ref{img56:constructorTypeInferenceExample} shows a simple usage where the underscore represents the inferred type argument.
This argument is deduced using a type received from the \texttt{t} variable declaration which determines the \texttt{int} type to be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
List<int> t = new List<_>();
\end{lstlisting}
\caption{Syntax of the partial constructor type inference.}
\label{img56:constructorTypeInferenceExample}
\end{figure}
\par
Similar to the partial method type inference, the \texttt{?} operator is allowed to append to determine the type nullability of the inferred type argument.

\subsection{Typename Lookup}

The typename lookup is done in the same way as in the partial method type inference. 
The binding of the underscore identifier is skipped. 
The underscore represents an inferred type, which has to be resolved during type inference. 
The inferred arguments are allowed only in the argument list of the type containing the called constructor.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new GenericWrapper<_>.CreatingClass<_>(arg1,...); // Not allowed
new GenericWrapper<int>.CreatingClass<_>(arg1,...); // Allowed
\end{lstlisting}
\caption{Allowed inferred type arguments.}
\label{img59:TypeArgList}
\end{figure}
So, if there is a generic type containing a nested class that is being created, the type arguments of the generic class have to be provided. 
This limitation is shown in Figure \ref{img59:TypeArgList}, where the first statement is invalid since it contains inferred type arguments in the \texttt{GenericWrapper} identifier, which doesn’t contain the called constructor. 
However, the second statement is valid because inferred type arguments are only in the \texttt{CreatingClass} identifier, which contains the called constructor.

\subsection{Argument Binding}

The mentioned target-typed inference complicates the binding of the arguments. 
When a target is an assigned variable or a return statement, the type of the target is given by the declaration of the variable or method’s return type. 
However, when the target is an argument of the other method, the type doesn’t have to be known during the argument's binding yet if the method is generic. 
Figure \ref{img60:target} shows a scenario when, at the time of binding the \texttt{Foo} creation expression, the target type is unknown because the binding order is from the constructor’s arguments to the constructor call. 
Without the target type, \texttt{Foo}'s type argument can’t be inferred. 
The \texttt{Bar} creation expression should be bound first, which would infer the type of the first parameter, which could be used as a target type of the \texttt{Foo} creation expression.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class Bar<T> {
    public Bar(Foo<T> arg1, T arg2) {}
}
class Foo<T> {}
...
new Bar<_>(new Foo<_>(), 1);
\end{lstlisting}
\caption{Target as an argument.}
\label{img60:target}
\end{figure}
\par
This process was mentioned regarding the target-typed \texttt{new()} operator.\\ 
Roslyn binds the operator in the following way. The operator is bound as an unconverted bound element which needs to be converted in the future. 
When the right overload of the method is chosen, Roslyn has to generate the necessary conversions of these arguments, which don't have an identical type as the corresponding parameter. 
At that time, the operator is converted by using the already-known target type. 
The result of the conversion is the binding of the object creation expression, which type is the target type.
Its arguments are contained in the type operator’s argument list.
\par
The improvement is inspired by that. 
When there is an object creation expression as an argument, and the argument is not needed for the inference success(the corresponding parameter doesn't contain a type parameter), a similar unconverted bound element is created.
Otherwise the argument is bound without the target type.
After the overload resolution, when the types of parameters are known, and the necessary conversion is started to be created, the unconverted object creation expression is tried to be bound with the already known target type. 
The compiler has to be careful here. 
It has to bind the object creation expression with and without a target type no more than once to prevent exponential time of binding.
\par
Figure \ref{img61:exp} shows a scenario where if the compiler does not do that, it will cause an exponential time of binding the expression. 
Since the constructor of the \texttt{Bar} type is overloaded, the overload resolution has to check these two overloads. 
Each of these checks includes binding of arguments, type inference, and checking of the applicability of bound arguments on the inferred constructor. 
Since the binding of arguments contains binding of the similar object creation expression, it will make the same overload resolution containing all overloads of the constructor. 
The target type can’t be provided here because the type argument is still unknown. 
When the binding of this argument is unsuccessful, the argument will be represented as an unconverted bound element and will be bound later after the resolution. 
This failure will happen for each overload resolution, which wastes time because it does the same computation multiple times. 
After the outer object creation expression is inferred using the type of the second argument, it will convert the inner object creation expression by providing the target type, which will finally resolve the object creation expression. 
This repeating failure would not be problem for the \texttt{new()} operator since it is cheap to express it automatically as an unconverted bound expression.
However, it is a problem for binding the object creation expression which can take long time.
\par
The following observation offers a way to avoid it.
The arguments can be bound before the overload resolution without target types.
The arguments' bindings, which will fail due to missing target type information will be bound after the overload resolution when a final used overload will be choose.
This strategy binds each expression no more than twice. 
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class Bar<T>{
    public Bar(Foo<T> arg1, T arg2){}
    public Bar(Foo<T> arg1, List<T> arg2){}
}
...
new Bar<_>(new Bar<_>(null, null), 1);
\end{lstlisting}
\caption{Potential exponential time of binding.}
\label{img61:exp}
\end{figure}

\subsection{Type Inference Algorithm}

The previously mentioned partial method type algorithm is unchanged except for collecting new bounds in the first phase of the algorithm. 
If a target type is provided, the upper bound type inference is made from it to the partially inferred type containing the constructor. 
If the inferring type contains the \texttt{where} clause containing type parameter constraints, for each of the type constraints which represent either inheritance constraints or interface implementation constraints is performed the lower bound type inference from it to the corresponding type parameter.
\par
Figure \ref{img62:ctro} shows an example of the partial constructor type inference, where both of the type arguments of the \texttt{Bar} type are inferred. 
The algorithm will create four type variables. 
The first two variables will represent type arguments, and the second two variables will represent the underscores.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
interface IBar<T> {}
class Bar<T1, T2> : IBar<T1> where T2 : object {}
...

IBar<int> t = Bar<_, _>();
\end{lstlisting}
\caption{Example of type inferences.}
\label{img62:ctro}
\end{figure}
In the first phase, the lower bound type inference is made from the \texttt{IBar<int>} type to the \texttt{Bar<\_,\_>} type, which will yield in the \texttt{int} lower bound of the type variable representing the first underscore. 
Then, the type constraint of the \texttt{T2} type parameter causes another lower bound type inference from the \texttt{object} type to the type variable representing the \texttt{T2} type parameter. 
Shape inference will relate type variables representing underscores with type variables representing type parameters. 
Then, the fixation will be made, and it will result in the \texttt{Bar<int, object>} inferred type.

\subsection{Initiliazer Extension} \label{sect12:ex1}

Initializers can be a part of the object creation expression, which allows us to use it as another source of type information. 
As the thesis mentions in the previous chapter, initializers are a syntax sugar. 
In the case of an object initializer, it represents a field assignment. 
If the field declaration contains a type parameter, the type of initializer element can be used to deduce the type parameter. 
Figure \ref{img58:initializer} shows an example of an initializer when the \texttt{Bar}’s type argument \texttt{int} can be deduced using type information from the initializer. 
Since the \texttt{Field} declaration type is the \texttt{T} type parameter and the \texttt{int} value is assigned to that field in the initializer, the compiler can deduce that the type argument is \texttt{int}. 
The improvement would allow this inference by performing the lower bound type inference for each item in the initializer. 
The inference would be made from the type of assigning expression to the type of the field’s type declaration.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class Bar<T> {
    public T Field;
}
...
new Bar<int>{ Field = 1 };
\end{lstlisting}
\caption{Object initializer.}
\label{img58:initializer}
\end{figure}
\par
A similar deduction can be made with array initializers where the element’s type is inferred.
The improvement would allow it by performing the lower bound type inference for each item in the initializer list. 
The inference would be made from the type of assigning expression to the inferred type of array’s element.
\par
However, collection initializers have been shown to be a little tricky. 
Since it is a syntax sugar for calling the special \texttt{Add} method for each element, the method can be overloaded. 
The previous section regarding Hindley-Millner type inference mentions that overloading can cause an exponential time of the type inference computation because it has to reason about each overload separately from the rest of the inferred bounds. 
To prevent slow compilation because of this issue, the improvement would allow the use of the information for the initializers in the case where the \texttt{Add} method is not overloaded. 
This limitation seems to be reasonable since a lot of collections from the standard library don’t overload the method. 
When there is no overload, the issue with the time complexity disappears. 
So when the \texttt{Add} method is not overloaded, the first phase of the type inference algorithm would additionally make the lower bound inference for each item in the initializer. 
The inference would be made from the type of the expression to the type of method parameter.
\par
The last initializer type regards indexers.
Since indexers can be considered as a special case of methods that can be overloaded as well, the same process would be made.

\subsection{Diamond Operator Extension} \label{sect13:ex2}

Since the partial constructor type inference is invoked when the creating type contains inferred type arguments in its type argument list, it can feel like a boilerplate when all type arguments are inferable. 
Figure \ref{img57:diamondExample} shows an example of creating the \texttt{Dictionary} generic type whose all type arguments can be inferred using the target type. 
Although C\# allows the definition of generic types with the same name and different arity, there are a lot of situations where the typename represents only one type in the current scope.
In the given example, the current scope contains only one generic definition for the \texttt{Directory} typename, so specifying the arity in the example is redundant in this case.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
System.Collections.Generic;

IDictionary<int, string> t = new Dictionary<_,_>();
\end{lstlisting}
\caption{Reduncant specification of arity.}
\label{img57:diamondExample}
\end{figure}
\par
For these use cases, where the compiler can confidently choose a generic type without looking at the arity, the diamond operator can be used to turn on the type inference. 
Figure \ref{img58:diamondExample2} shows the usage of the diamond operator with the \texttt{Dictionary} type. 
Supposing that there is no other definition of \texttt{Dictionary} type with a different arity in the current name scope, the compiler can assume that the referring type is the \texttt{System.Collections.Generic.Dictionary<,>} type from the standard library.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IDictionary<int, string> t = new Dictionary<>();
\end{lstlisting}
\caption{Diamond operator.}
\label{img58:diamondExample2}
\end{figure}

\section{Partial Type Inference During Dynamic\\ Member Invocation} \label{sect11:dynamic}

Inferred type arguments can appear in an expression containing a dynamic value which is still checked by the compiler in the limitted way mentioned in the C\# Programming Langauge chapter \ref{sect15:dyn}.
We have to adjust this check to reflect the described improvements.
The compiler checks three relevant expression types containing the dynamic value as an argument. 
It is a static method invocation, instance method invocation whose receiver is not a dynamic value, and object creation expression. 
For each candidate of this kind, a modified parameter list and argument list are created to be checked for applicability. 
If there is no candidate for which the test succeeds, a compile-time error occurs.
\par
The modified parameter list is created in the following way. 
If the candidate is a generic method and type arguments were provided, it substitutes them in the parameter list. 
Then, all parameters that include a type parameter are elided with corresponding arguments. 
The resulting set of parameters and arguments are checked for the applicability.
\par
The thesis removes this check since the type hints are not considered during the binding in runtime and announces a warning about using partial type inference in late-binding, which is not supported since it is handled by the runtime. 
There are situations where the runtime is able to infer type arguments even with used underscores in the type argument list. 
Figure \ref{img63:dinamic} shows an example where the \texttt{Foo} method is inferred by runtime because inferred type arguments are inferrable in the runtime. 
These situations are valid, and hence, the compiler should just warn about them.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
void Foo<T1, T2>(T1 arg1, T2 arg2) {}
...
dynamic t = ...
Foo<_, _>(t, 1);
\end{lstlisting}
\caption{Runtime type inference.}
\label{img63:dinamic}
\end{figure}

\section{Other Type Inference Improvements}

Besides the proposed improvement described above, the work touched on surrounding areas of type inference during the initial problem exploration. 
The chapter gives a couple of thoughts about touched areas since they were also investigated and can be a future extension of the C\# programming language.

\subsection{Shared Type Inference Context}

C\# currently has a local type inference preventing advanced type inference. 
The next big improvement of the type inference would be to provide global type inference using inferring contexts similar to Rust's. 
However, since it would bring a breaking change, it would require an additional tool that would patch the old code to work in the same way compiled with the new type inference. 
This refactoring can be challenging, so at least it should warn the user about possible behavior changes in each place where it can occur.

\subsection{Inferring Return Value of Methods}

The work already mentioned the possibility of inferring the return value type of the method, which can be beneficial for writing a simple method whose name indicates the return value, helping a reader to understand the code. 
An example of the function can be \texttt{ToString}, which indicates that the return value is the \texttt{string} type.
\par
This language feature can be seen in the Kotlin programming language, which allows the definition of a method without a return type if the method is exactly one expression. 
The Kotlin language is a strongly typed language developed by JetBrains. 
Kotlin’s main target is JVM, and its goal is to be an alternative to Java with excellent interoperability between these languages to use them almost interchangeably in one project. 
Because of that, it has a similar type system as Java, which is not far away from C\#. 
Figure \ref{img64:kotlin} shows an example of the \texttt{MyClass} definition containing the \texttt{toMyString} method definition. 
The signature consists of the \texttt{fun} keyword, the name, and the equal sign followed by one expression. 
The method's return type is inferred based on the expression's return value.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class MyClass {
    fun toMyString() = "TEXT"
}
\end{lstlisting}
\caption{Kotlin return type inference.}
\label{img64:kotlin}
\end{figure}
\par
The main obstacle regarding the inferred return type in methods' signatures is an order of compilation and possible multithreaded compilation.
The Roslyn compiler first finds all definitions in the program, which allows it to compile methods separately in different threads.
This advantage is because the method's content consists of only types and methods defined in the program, whose signatures are already known thanks to the previous phase.
So, the compiler knows the exact return types of the used functions, which allows it to do a type check.
\par
Kotlin divides the method compilation into two groups, as it is described in the video \cite{online:kotlinCompiler}. 
The first group contains methods without a return type, which is compiled first in a single thread. 
This will allow to obtain all signatures for these methods in the program. 
Obviously, if these methods are recursions, the compiler can’t infer the return type, and an error occurs.
The second group contains methods with a return type, which can be compiled in multiple threads since all method signatures are already known.
\par
Although this implementation would be possible in Roslyn as well, it would require a large number of changes. 
Instead of that, C\# could allow inferring return in a local function, which is a function defined inside a method body and can be used only inside the method. 
There are two benefits of it. 
The main architecture of the Roslyn compiler doesn’t have to be changed since the method is compiled by one thread, and the local functions can’t be used outside. 
Local functions are usually tied with the method implementation, and the return type is not contained in the public API, so a reader shouldn’t need to know the return type till the time when he/she wants to explore the inner implementation, which gives him/her a context to deduce the return type by himself.


