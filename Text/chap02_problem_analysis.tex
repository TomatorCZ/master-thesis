\chapter{Problem analysis}
\info{Describe the chapter}
The chapter divides the analysis into four sections. 
The first section describes the scope of the improvement based on the mentioned championed issue recommended by \ac{LDT}. 
The second section mentions a concrete motivation which leads us to the proposed improvement. 
The third section determines requirements based on the motivation, requirements given by proposing new language features, and Roslyn implementation internals. 
The fourth section describes the proposed language feature design, which is inspired by C\# language feature ideas mentioned in the previous chapter and validated by the requirements.
The last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements. 

\section{Scope}
\info{Describe why we choose only a small part of the C\# type inference}
The previous chapter indicates that type inference is a complicated process, where even the current C\# method type inference is difficult to understand. 
Hence, the thesis chooses a small part of C\# where it improves and introduces the type inference and would be possible to reason about and implement in the scope of this text. 
The second reason for choosing a minor change is that introducing a completely new type inference in C\# would rather have an experimental result, which would have a smaller chance of getting into production, which is different from the intention of this work. 
However, some more extensive changes in the type inference will also be mentioned to outline possible obstacles to introducing them in the C\#.
\par
\info{Specify the focus on partial type inference}
The thesis focuses on the already-mentioned \textit{partial type inference} proposal, which was recommended by a member of \ac{LDT} and has a chance to be discussed in \ac{LDM} and potentially accepted. 
Analysis of this improvement contains a consideration of existing ideas, their consequences on C\#, and their difficulties in implementing them in Roslyn. 
Additionally, the work describes the relation to the Hindley-Millner formalization to express the strength of the type inference in a formalized way, which can be further used to compare it with other kinds of type inference in different programming languages and which decides the theoretical boundaries of the C\# type inference.

\section{Motivation}
\info{What is partial type inference and why it is useful}
Partial type inference focuses on hinting the compiler ambigious type arguments of generic type or method in situations, where it can't deduce them.
In the context of C\#, the only type inference which infers type arguments is method type inference mentioned in the previous chapter.
The need of providing hints to the compiler is caused by the weakness of the method type inference.
The following three real-world examples demonstrate common issues with method type inference weakness which will be a target to solve.
\par
\info{Weakness of current method type inference - target typing}
The first weakness ragards target typing mentioned in the previous chapter.  
Let's suppose an hypotetical situation when an user querries an item from a database whose collumn is a point of interest.
Figure \ref{img27:usecase1} shows an example of code which uses the \texttt{fetch} method definined on a database type.
The \texttt{data} variable represents data fetched from a database.
Since a concrete form of data is unknown, the data has the type of \texttt{object} containing internal representation of fetched data which has the collumns stored as fields.
There is the \texttt{GetField} method enabling to read the variable's field of the given name with the supposed type given as a type argument.
Suppose, the fetched object contains a "name" field containing a string value.
Now, an user wants to store the value into the \texttt{name} variable, which is explicitly typed.
Even that the return type of the \texttt{GetField} method is known from the variable declaration and which also is the \texttt{TReturn} type argument of the method, an user has to still specify the type argument in the call.
Generally, this problem consists of all type inferences which depends on the target type.
The target can be an argument of another method call, or a assigning field.
If the method type inference would consider the target type, an user will not have to specify the \texttt{string} type argument in the \texttt{GetField} call.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
object data = database.fetch();
string name = data.GetField<string>("name");
...
static class Extensions {
    static 
    TReturn GetField<TReturn>(this object inst, string fieldName) 
    {...}
}
\end{lstlisting}
\caption{Target-typed inference.}
\label{img27:usecase1}
\end{figure}
\par
\info{Weakness of current method type inference - Constraints-based inference}
The second weakness is noticable in more advanced generic APIs, like testing frameworks, using type contstaints containing the type parameters.
Figure \ref{img28:usecase2} shows a scenario of a simple test framework which defines the \texttt{Test} method parameterized by a type of input data and test case represented as type parameters \texttt{U} and \texttt{V} respectively.
The providing type argument representing test case has to inherit the \texttt{TestCaseBase} base implementation which is a generic type paramertrized by a type of the input data.
This constraint gives an type information about the \texttt{T} type parameter which is related to the type of input data.
However, an user has to specify type arguments in the \texttt{Test} call since the type inference doesn't consider this source of type information.
If the compiler would consider the constraint, the type arguments will be inferred saving the type annotations.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Test<TestCaseBase<MyData>, MyData>(new MyData());
...
void Test<T, U>(U data) where T : TestCaseBase<U> {...}
\end{lstlisting}
\caption{Constraints-based inference.}
\label{img28:usecase2}
\end{figure}
\par
\info{Weakness of current method type inference - all or nothing principle}
There are also situations where even strong type inference is not enough.
Figure \ref{img29:usecase3} shows a situation where there is the \texttt{log} method parametrized by two type parameters which are obtained in the parameter types and hence inferable by the compiler.
However, the \texttt{log} method call has to still specify type arguments because the \texttt{null} argument doesn't have a concrete type information.
In this case, an user always has to specify the second type argument, but the first type argument can be inferred by the compiler.
The thesis reffers this problem as \textit{all or nothing} principle which regards the obligation to specify all type arguments or none of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<Message, Appendix>(new Message(...), null);
...
void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Uninferable type argument.}
\label{img29:usecase3}
\end{figure}
\par
\info{Breaking changes - Possible improvement of method type inference}
The first and the second weaknesses motivate us to extend the method type inference in order to consider wider context for obtaing type informations for the type arguments.
This potential improvement shown to be a problem for the compiler back-compatibility.
New versions of the compiler should be back-compatible to not change the behavior of code compiler by its older version.
\par
\info{Breaking changes - target-typing}
Figure \ref{img30:breakingChange1} shows the breaking change, when method type inference starts to consider target types.
Before the improvement, \texttt{M} method call it resolved to the non-generic version of this method because type inference can't infer the \texttt{T} type argument.
After the improvement, the type inference infers \texttt{T} to be the \texttt{int} type which is more specific to thetype of \texttt{1} argument than the \texttt{long} type.
So now, the \texttt{M} method call refers to the generic version of this method and executes different code without any warning or error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
int name = M(1);
...
T M<T>(int p1) {...}
int M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Target-typed inference.}
\label{img30:breakingChange1}
\end{figure}
\par
\info{Breaking changes - Constraints-based inference}
Figure \ref{img31:breakingChange2} shows the similar situation when the method type inference starts to consider type parameter constraints.
Before the improvement, the \texttt{M} method call refers to the non-generic version of the method since the type inference can't infer the type argument of generic version.
After the improvement, the generic version is inferred to have the \texttt{int} type argument and becomes to be more suitable for the overload resolution.
So the code behavior changed again because of compiling it with different version of compilers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
M(1);
...
void M<T>(int p1) where T : List<int> {...}
void M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Constraints-based inference.}
\label{img31:breakingChange2}
\end{figure}
\par
\info{Possible method type inference improvement doesn't solve the third weakness}
Besides the breaking change, the potential method type inference improvement to use begger context still doesn't solve our third example demonstrating a type parameter, which doesn't appear in parameter types, return type, and it is not contained the the type parameters' constraints.
These obstacles gives the reason for introducing a way how to hint just ambigious type arguments to the compiler.
\par
\info{Partial type inference - reduces the first and second weakness}
Considering partial type inference, it can sort of reduce the first two weaknesses.
Type arguments, which can't be inferred by the method type inference, can be hinted avoiding to specify the whole type argument list.
Let's ignore for now the reason why the underscore character is used and the way how inferred type variables are determined in the following example.
Figure \ref{img32:sol1} shows an usage of partial type inference applied on the second presented example regarding method type inference weaknesses.
Although the first type argument of the \texttt{Test} method call has to be still provided, the second argument is ommited by using the underscore character determining a inferred type argument.
The reduction of first weakness is to isolate the unsuficient type inference to type arguments which are directly influenced by it and infer the rest.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
test<TestCaseDefault<MyData>, _>(new MyData());

void test<T, U>(U data) where T : TestCaseDefault<U> {...}
\end{lstlisting}
\caption{Partial type inference: Reducing method type inference weakness.}
\label{img32:sol1}
\end{figure}
\par
\info{Breaking changes - solves the third weakness}
The third motivation example confirms that partial type inference is not just a fix of missing type inference feature, but needed in situations where type arguments can't by inferred at all.
Figure \ref{img33:sol2} demonstrated an usage of partial type inference where it ommits the first type argument since it can be deduced from the first argument type and specify the amigious type which can't be deduced. 
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<_, Appendix>(new Message(...), null);

void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Partial type inference: Solving the \textit{all or nothing} problem.}
\label{img33:sol2}
\end{figure}
\par
\info{Constructor type inference - next motivation and improvement}
Partial type inference doesn't regard only method type inference.
It can be also introduce in other places.
One of that places which seems to be good for that is object creation expression.
Except already mentioned \texttt{new()} operator, there are no other type inference which would help to infer type arguments of a construing generic type.
Since \texttt{new()} operator requires a target type to infer the construing type, the usage is limited.
Figure \ref{img34:wrapper} shows an example of the limitation, where \texttt{new()} operator can't be used since the \texttt{IWrapper} target type is not the \texttt{Wrapper<int>} construing type.
Hence an user has to specify the whole type with the \texttt{int} type argument wven it could be inferred using the argument type.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<int>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{C\# wrapper class.}
\label{img34:wrapper}
\end{figure}
\par
\info{Constructor type inference - Factory method workaround}
In principle, the object creation can be consider as a special case of a method call with a side effect(creating the object) which aready has method type inference.
Figure \ref{img35:workaroung} shows a workaround using \texttt{Create} method delegating the creation to construction call.
Since the method call type arguments can be inferred, it allows to use the method type inference for inferring type arguments of construing type.
However, this solution has disadvantages like necessary boiler-plate and prohibition of using initializers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = Create(1);

static Wrapper<T> Create<T>(T item) => new Wrapper<T>(item);
\end{lstlisting}
\caption{Workaround of constructor type inference.}
\label{img35:workaroung}
\end{figure}
\par
\info{Constructor type inference - strength of method type inference}
A possible solution would be to use method type inference in object creation expression.
Although this solution would be simple to implement, class type parameters are more likely not to be used in constructor paramater types which makes the method type inference useless.
Besides that, options for inferring type arguments of construing type is not limited by not introducing breaking changes since there is no type inference at all.
So there is a possibility to interoduce even stronger type inference which could be one day introduce in the method type inference when there will be a way how to introduce breaking changes in the new version of compiler.
Figure \ref{img36:cti} shows an example of such a generic class whose all type parameters are not used in the constructor.
Because of that, potential method type inference extended to be used in object creation expressions would be useless since the \texttt{TLogger} can't be inferred only from parameter types.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class Algorithm<TData, TLogger> where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Use case iusing type paraemter constraints.}
\label{img36:cti}
\end{figure}
\par
\info{Constructor type inference - the first weakness solution}
Introducing improved type inference based on method type inference would solve mentioned issues.
Figure \ref{img37:sol1} shows a potential usage of that type inference in the first case regarding the \texttt{Wrapper} class where an underscore is used to represent inferred type argument.
The inference than uses the parameter type of the constructor to infer the \texttt{T} parameter type which is \texttt{int}.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<_>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{Constructor type inference: Wrapper.}
\label{img37:sol1}
\end{figure}
\par
\info{Constructor type inference - better method type inference}
Figure \ref{img38:sol2} shows a potential improvements of the type inference.
The first statement of initializing \texttt{alg} variables uses type inference levering \texttt{TLogger}'s constraint to determine its type.
The second statement demonstrates a possibility to have a nested underscore which allow to more specify the type argument. 
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var alg = new Algorithm<_, _>(new MyData());
var algWithSpecialLogger = 
    new Algorithm<_ , SpecialLogger<_>>(new MyData());

class Algorithm<TData, TLogger> 
    where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Constructor type inference: stronger method type inference.}
\label{img38:sol2}
\end{figure}
\par
From now on, thesis calls \textit{constructor type inference} for introducing such a type inference.

\section{Requirements}
\change{Decribe requirements given by use cases}
\change{Describe requirements given by Roslyn}
\change{Describe requirements given by Future improvements}
\change{Describe requirements given by back compatibility}
\change{Describe requirements given by new language feature proposing}

\section{Language feature design}

\change{Discuss mentioned ideas}
\change{Choose suitable subset of them}
\change{Divide it as in the proposal}
\change{Explain why they sucsess the requirements}

\section{Other type inference improvements}

\change{Shared type inference context}
\change{Inferring return value of methods}