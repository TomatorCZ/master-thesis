\chapter{Solution}

The solution consists of a proposal describing the language feature given in the previous chapter \ref{sect09:lang} and an implementation of the prototype in a separate Roslyn branch.

\section{Proposal}

The final version of the proposal can be found in the \texttt{attachment} folder as the \texttt{partial-type-inference.md} file. 
The file’s format is a standard Markdown used widely in readme files for its advantage of being able to be read without specialized tools visualizing the formatting.

\subsection{Creation process}

The proposal had three stages of development. 
The first version of the document was created in a personal repository \cite{online:personalRepo}, where it was reviewed by a member of Roslyn's development team. 
The review was in the form of a pull request \cite{online:personalPull} where the member suggested several changes on how to structure the proposal and how to refer to the original C\# standard documentation and pointed out possible improvements that would be beneficial to investigate.
\par
After the revisions were made, the member recommended to post it as a discussion \cite{online:discussion1}, which was the first time when a wider community could comment on the proposal. 
Besides several upvotes received from anonymous readers, another member of Roslyn's development team started to give his recommendations on how to adjust the document. 
The main change of the improvement was to erase most of the examples taken from the tests made together with the prototype and replace them with more references to the original C\# documentation.
\par
The third version of the improvement was published as the next discussion \cite{online:discussion2}, where it received even more emoticons as likes or hearts, which was a good sign of progress. 
At that time, the discussion contained just answers to the questions raised by the member of the Roslyn team, which clarified the intention of the improvement.
\par
After this step, the third stage was made by publishing the proposal as a pull request \cite{online:pull2}. 
This step was done after the recommendation from the team member. 
The pull request was continued by another round of clarifications, recommendations, and revisions from three members of Roslyn's team.
\par
The current stage of the proposal at the time of writing is that the pull
request is still open, waiting for the next requirements from the \ac{LDT}.

\subsection{Content}

The whole document has two styles of describing the feature. 
The first style explains the intention of the improvement and necessary relations, which helps to understand it. 
The second style used in the detailed design section is rather a patch of C\# standard documentation, which enables improvement. 
So, the text doesn’t contain fluent sentences but fragments of the documentation that need to be changed.
\par
The proposal consists of five parts. 
The first part gives a quick overview of the proposed change, summarizing it in a few sentences.
\par
The second part describes the motivation why it should be done. The text
and the used examples are similar to those in section \ref{sect10:mot}.
\par
The third and largest part contains a detailed design of the improvement. 
There is a description of grammar change, where it explains a new underscore contextual keyword in the type argument list. 
It is followed by the change of binding method invocation and object creation expressions. 
This part describes the mentioned core design of the improvement with the changed method type inference algorithm. 
The design ends with extending compile-time checking dynamic member invocation, which is explained in section \ref{sect11:dynamic}.
\par
The fourth part comments on the reason for not doing other alternatives contained in the discussions. 
It also mentions two possible extensions of the improvement using the diamond operator \ref{sect13:ex2} and initializers \ref{sect12:ex1} in the type inference context.
\par
The last part suggests other potential improvements given in the future improvements section \ref{sect14:future}.


\section{Implementation}

The already mentioned proposal will be tested by the implementation described in this section. 
The goal of the implementation is to observe the consequences of the proposed feature in a practical way, which can be tried by C\# communitity. 
The goal will be achieved by contributing to the forked Roslyn project on GitHub, which is public. 
Since the proposal is in the state of probing the benefits, the implementation will be rather a proof of concept than a ready-to-production code.

\subsection{Development environment}

Since the compiler is a complicated program consisting of many parts, the creators provide a guide \cite{online:roslynGuide} describing a common workflow including building the compiler, writting tests and the deployment.
\par
We start with cloning the Roslyn repository \cite{online:roslynRepo} and opening it in an IDE.
There are several IDEs, which can be used.
We recommend Visual Studio 2022 \cite{online:vs} which is used to implement the proposal.
The IDE is chosen since it is recommended by the Roslyn folks and provides helpful static code analysis and a debugger which is almost necessary in cases, when a programmer is not familiar with the code base.
However, hardware requirements for opening the repository are quite high in terms of memory consumption when for a smooth experience with browsing and launching the code it requieres around 20 GB of RAM.
So we recommend Visual Studio Code \cite{online:vsCode} in cases, when the hardware resources are limitted as a compensation for worse code analysis.
\par
However, the IDE is not required for launching or deploying the compiler.
The first thing which is necassary for building is a correct version of .NET SDK specified in \texttt{global.json} placed in the rool project.
We use SDK \texttt{8.0.1} which can be downloaded from Microsoft original websites \cite{online:sdk}.
We also use Windows operating system, although the deployment should be possible on Linux or Mac OS as well.
\par
Since the building for large programs like a compiler can be complicated, the root folder provides three scripts which take care of it.
The \texttt{Restore.cmd} script is run firstly to download required packages.
The \texttt{Build.cmd} srcipt is used to build the compiler and the \texttt{Test.cmd} script is used to run tests of the compiler.
The scripts have multiple options which modificates the workflow.
We will mention few of them which is needed for the implementation.

\subsubsection{Testing}

Launching the tests of compiler is done by a sequence of Windows command console commands shown in Figure \ref{img65:runTests}.
Since the repository contains also an implemention of an C\# extension to Visual Studio, tests are divided into several groups which test indenpendent part of the compiler.
In our case, we use the \texttt{-testCompilerOnly} flag to run basic compiler tests.
The tests will be a base line which has to be passed by the implementaion of the proposal.
The result of \texttt{Build.cmd} command is built compiler placed in the \texttt{roslyn/artifacts} folder.
Tests results are stored in the \texttt{Roslyn/artifacts/TestResults} folder as \texttt{.xml} files and \texttt{.html} files for displaying it in the browser.
\begin{figure}[h]
\begin{lstlisting}
Restore.cmd
Build.cmd
Test.cmd -testCompilerOnly
\end{lstlisting}
\caption{Running C\# compiler tests.}
\label{img65:runTests}
\end{figure}
\par
The results of the tests, when we started the implementation, can be seen in the attachment folder \texttt{/Attachment/TestResults/Initial}, where two tests regarding Visual Basic were not passed.
Since our contribution is the the C\# compiler, we ignore it.

\subsubsection{Deployment}

The standard deployment of a new compiler version is bundling it with a new version of the SDK which would require compiling the SDK from sources.
However, there is a possibility to inject own version of the compiler to already installed SDK.
This option was created to temporary hot fix compiler problems delivered with a SDK.
Since the implemention is a proof of concept, this option will be sufficient to check the main functionality of the proposal directly in user's code.
\par
The injection is done by referencing a special package generated by the \texttt{Build.cmd} script in a project file of a target C\# project using partial type inference.
The nuget cache containg .NET packaged needs to be modified before the package generation.
The nuget cache is usually placed in the \texttt{C://Users/\%user\%/.nuget} folder on Windows, where is required to delete the version of \texttt{Microsoft.CSharp.Net.Compiler.ToolSet} package which will be generated by the \texttt{Build.cmd -publish} command.
The command generates the \texttt{roslyn/artifacts/publish/Shipping} folder containg the \texttt{Microsoft.CSharp.Net.Compiler.ToolSet} package which needs to be referenced.
Additionally to the package reference, the project file has to define a folder containing the package which will be used for restoring the packages in the nuget cache.
The last thing is specifying of a language version which has to be set to \texttt{preview} enabling the partial type inference. 
Figure \ref{img68:csproj} shows a modified project file of demo application which can be found in \texttt{Attachment/Demo} folder.
The \texttt{PropertyGroup} element contains a definition of language version and a folder for package restoration.
The \texttt{ItemGroup} element contains a definition of the package reference injecting the locally built compiler. 
\begin{figure}[h]
\begin{lstlisting}
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>preview</LangVersion>
        <RestoreSources>
      E:\roslyn\artifacts\packages\Debug\Shipping
    </RestoreSources>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference 
      Include="Microsoft.Net.Compilers.Toolset" 
      Version="4.9.0-dev"
    />
  </ItemGroup>
</Project>
\end{lstlisting}
\caption{\texttt{Demo.csproj}}
\label{img68:csproj}
\end{figure}
\par
Then, a common \texttt{dotnet build} command can be used to compile the project using own compiler version instead of the bundled one.
There is an easy way to check the currently used compiler by puting the \texttt{\#error version} pragma anywhere into the compiled code.
Figure \ref{img66:pragma} shows the usage of the pragma in the demo application.
\begin{figure}[h]
\begin{lstlisting}
using System;

#error version

class Program {
...
\end{lstlisting}
\caption{Begining of \texttt{Program.cs}.}
\label{img66:pragma}
\end{figure}
\par
When the project is compiled again, it will raise a compilation error annoncing current version the package which is shown in Figure \ref{img67:output}.
We can see, that the code was compiled by \texttt{4.9.0-dev} compiler version and the langauge version was set to \texttt{preview}. 
\begin{figure}[h]
\begin{lstlisting}
E:\Demo>dotnet build
MSBuild version 17.8.3+195e7f5a3 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
E:\Demo\Program.cs(4,8): error CS1029: 
  #error: 'version' [E:\Demo\Demo.csproj]
E:\Demo\Program.cs(4,8): error CS8304: 
  Compiler version: '4.9.0-dev (<developer build>)'. 
  Language version: preview [E:\Demo\Demo.csproj]

Build FAILED.

E:\Demo\Program.cs(4,8): error CS1029: 
  #error: 'version' [E:\Demo\Demo.csproj]
E:\Demo\Program.cs(4,8): error CS8304: 
  Compiler version: '4.9.0-dev (<developer build>)'. 
  Language version: preview. [E:\Demo\Demo.csproj]
    0 Warning(s)
    2 Error(s)

Time Elapsed 00:00:09.19
\end{lstlisting}
\caption{Output of building \texttt{Demo.csproj}}
\label{img67:output}
\end{figure}

\subsection{Repository overview}

\change{code overview}

\subsection{Test suite}

\change{Describe test framework and testing}

\subsection{Parsing inferred type arguments}

\change{Describe change in parsing}

\subsection{TypeInferrer}

\change{Describe rewritten type inferrer}

\subsection{Binding partial-inferred method}

\change{Describe the binding}

\subsection{Binding partial-inferred object construction}

\change{Describe the binding}

\subsection{Nullable walker}

\change{Decribe nullable walker}