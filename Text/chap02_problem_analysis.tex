\chapter{Problem analysis}
\info{Describe the chapter}
The chapter divides the analysis into four sections. 
The first section describes the scope of the improvement based on the mentioned championed issue recommended by \ac{LDT}. 
The second section mentions a concrete motivation which leads us to the proposed improvement. 
The third section determines requirements based on the motivation, requirements given by proposing new language features, and Roslyn implementation internals. 
The fourth section describes the proposed language feature design, which is inspired by C\# language feature ideas mentioned in the previous chapter and validated by the requirements.
The last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements. 

\section{Scope}
\info{Describe why we choose only a small part of the C\# type inference}
The previous chapter indicates that type inference is a complicated process, where even the current C\# method type inference is difficult to understand. 
Hence, the thesis chooses a small part of C\# where it improves and introduces the type inference and would be possible to reason about and implement in the scope of this text. 
The second reason for choosing a minor change is that introducing a completely new type inference in C\# would rather have an experimental result, which would have a smaller chance of getting into production, which is different from the intention of this work. 
However, some more extensive changes in the type inference will also be mentioned to outline possible obstacles to introducing them in the C\#.
\par
\info{Specify the focus on partial type inference}
The thesis focuses on the already-mentioned \textit{partial type inference} proposal, which was recommended by a member of \ac{LDT} and has a chance to be discussed in \ac{LDM} and potentially accepted. 
Analysis of this improvement contains a consideration of existing ideas, their consequences on C\#, and their difficulties in implementing them in Roslyn. 
Additionally, the work describes the relation to the Hindley-Millner formalization to express the strength of the type inference in a formalized way, which can be further used to compare it with other kinds of type inference in different programming languages and which decides the theoretical boundaries of the C\# type inference.

\section{Motivation}
\info{What is partial type inference and why it is useful}
Partial type inference focuses on hinting to the compiler ambiguous type arguments of generic type or method in situations where it can’t deduce them. 
In the context of C\#, the only type inference that infers type arguments is the method type inference mentioned in the previous chapter. 
The weakness of the method type inference is the need to provide hints to the compiler. 
The following three real-world examples demonstrate common issues with method type inference weakness, which the thesis tries to solve.
\par
\info{Weakness of current method type inference - target typing}
The first weakness regards target typing, which was mentioned in the previous chapter. 
Suppose a hypothetical situation when a user queries an item from a database whose column is a point of interest. 
Figure \ref{img27:usecase1} shows an example of code that uses the \texttt{fetch} method defined on a database type. 
The \texttt{data} variable represents data fetched from a database. 
Since a concrete form of data is unknown, the data has the type of \texttt{object} containing an internal representation of fetched data with the columns stored as fields. 
The \texttt{GetField} method enables one to read the variable’s field of the given name with the supposed type given as a type argument. 
Suppose the fetched object contains the ”name” field containing a string value. 
Now, a user wants to store the value in the \texttt{name} variable, which is explicitly typed. 
Even though the return type of the \texttt{GetField} method is known from the variable declaration, which also is the \texttt{TReturn} type argument of the method, the user still has to specify the type argument in the call. 
Generally, this problem consists of all type inferences, which depend on the target type. The target can be an argument of another method call or an assigning field. 
If the method type inference considers the target type, the user will not have to specify the \texttt{string} type argument in the \texttt{GetField} call.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
object data = database.fetch();
string name = data.GetField<string>("name");
...
static class Extensions {
    static 
    TReturn GetField<TReturn>(this object inst, string fieldName) 
    {...}
}
\end{lstlisting}
\caption{Target-typed inference.}
\label{img27:usecase1}
\end{figure}
\par
\info{Weakness of current method type inference - Constraints-based inference}
The second weakness is noticeable in more advanced generic APIs, like testing frameworks, using type constraints containing the type parameters. 
Figure \ref{img28:usecase2} shows a scenario of a simple test framework that defines the \texttt{Test} method parameterized by a type of input data and test case represented as type parameters \texttt{U} and \texttt{V}, respectively. 
The providing type argument representing the test case has to inherit the \texttt{TestCaseBase} base implementation, which is a generic type parametrized by a type of input data. 
This constraint gives type information about the \texttt{T} type parameter, which is related to the type of input data. 
However, the user has to specify type arguments in the \texttt{Test} call since the type inference doesn’t consider this source of type information. 
If the compiler considers the constraint, the type arguments will be inferred, saving the type annotations.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Test<TestCaseBase<MyData>, MyData>(new MyData());
...
void Test<T, U>(U data) where T : TestCaseBase<U> {...}
\end{lstlisting}
\caption{Constraints-based inference.}
\label{img28:usecase2}
\end{figure}
\par
\info{Weakness of current method type inference - all or nothing principle}
There are also situations where even strong type inference is not enough.
Figure \ref{img29:usecase3} shows a situation where the \texttt{log} method is parametrized by two type parameters that are obtained in the parameter types and hence inferable by the compiler. 
However, the \texttt{log} method call still has to specify type arguments because the \texttt{null} argument doesn’t have concrete type information. 
In this case, the user always has to specify the second type argument, but the compiler can infer the first type argument. 
The thesis refers to this problem as \textit{all or nothing} principle, which regards the obligation to specify all type arguments or none of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<Message, Appendix>(new Message(...), null);
...
void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Uninferable type argument.}
\label{img29:usecase3}
\end{figure}
\par
\info{Breaking changes - Possible improvement of method type inference}
The first and the second weaknesses motivate us to extend the method type inference in order to consider a wider context for obtaining type information for the type arguments. 
This potential improvement is a problem for the compiler's back compatibility which was mentioned in the C\# discussion \cite{online:breakingChange}. 
New compiler versions should be back-compatible so that a new version does not change the behavior of the code compiled by the older version.
\par
\info{Breaking changes - target-typing}
Figure \ref{img30:breakingChange1} shows the breaking change when method type inference starts to consider target types. 
Before the improvement, the \texttt{M} method call is resolved to the non-generic version of this method because type inference can’t infer the \texttt{T} type argument. 
After the improvement, the type inference infers \texttt{T} to be the \texttt{int} type, which is more specific to the type of \texttt{1} argument than the \texttt{long} type. 
So now, the \texttt{M} method call refers to the generic version of this method and executes different code without any warning or error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
int name = M(1);
...
T M<T>(int p1) {...}
int M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Target-typed inference.}
\label{img30:breakingChange1}
\end{figure}
\par
\info{Breaking changes - Constraints-based inference}
Figure \ref{img31:breakingChange2} shows a similar situation when the method type inference starts to consider type parameter constraints. 
Before the improvement, the \texttt{M} method call refers to the non-generic version of the method since the type inference can’t infer the type argument of a generic version. 
After the improvement, the generic version is inferred to have the \texttt{int} type argument and becomes to be more suitable for the overload resolution. 
So, the code behavior changed again because of compiling it with a different compiler's version.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
M(1);
...
void M<T>(int p1) where T : List<int> {...}
void M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Constraints-based inference.}
\label{img31:breakingChange2}
\end{figure}
\par
\info{Possible method type inference improvement doesn't solve the third weakness}
Besides the breaking change, the potential method type inference improvement to use a bigger context still doesn’t solve our third example demonstrating a type parameter, which doesn’t appear in parameter types, return type, and the type parameters’ constraints. 
These obstacles give the reason for introducing a way to hint just ambiguous type arguments to the compiler.
\par
\info{Partial type inference - reduces the first and second weakness}
Partial type inference can reduce the first two weaknesses. 
Type arguments, which the method type inference can’t infer, can be hinted in order to avoid specifying the whole type argument list. 
Let’s now ignore why the underscore character is used and how inferred type variables are determined in the following example. 
The reasons behind that will be mentioned later.
Figure \ref{img32:sol1} shows the usage of partial type inference applied in the second presented example regarding method type inference weaknesses. 
Although the first type argument of the \texttt{Test} method call must still be provided, the second argument is omitted by using the underscore character to determine an inferred type argument. 
The reduction of the first weakness is to isolate the insufficient type inference to type arguments that are directly influenced by it and infer the rest.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
test<TestCaseDefault<MyData>, _>(new MyData());

void test<T, U>(U data) where T : TestCaseDefault<U> {...}
\end{lstlisting}
\caption{Partial type inference: Reducing method type inference weakness.}
\label{img32:sol1}
\end{figure}
\par
\info{Breaking changes - solves the third weakness}
The third motivation example confirms that partial type inference is not just a fix for missing type inference features but is needed when type arguments can’t be inferred at all. 
Figure \ref{img33:sol2} demonstrates a usage of partial type inference where it omits the first type argument since it can be deduced from the first argument type and specifies the ambiguous type that can’t be deduced.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<_, Appendix>(new Message(...), null);

void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Partial type inference: Solving the \textit{all or nothing} problem.}
\label{img33:sol2}
\end{figure}
\par
\info{Constructor type inference - next motivation and improvement}
Partial type inference doesn’t regard only method type inference. 
It can also be introduced in other places. One of the places that seems to be good for that is object creation expression. 
Except for the already mentioned \texttt{new()} operator, no other type inference infers type arguments of a construing generic type. The usage of the type inference is limited since the \texttt{new()} operator requires a target type to infer the construing type. 
Figure \ref{img34:wrapper} shows an example of the limitation, where the \texttt{new()} operator can’t be used since the \texttt{IWrapper} target type is not the \texttt{Wrapper<int>} construing type. 
Hence, the user has to specify the whole type with the \texttt{int} type argument, despite the fact that it could be inferred using method type inference.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<int>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{C\# wrapper class.}
\label{img34:wrapper}
\end{figure}
\par
\info{Constructor type inference - Factory method workaround}
In principle, object creation can be considered a special case of a method call with a side effect(creating the object), which already has method type inference. 
Figure \ref{img35:workaroung} shows a workaround using the \texttt{Create} method, delegating the creation to the constructor call. 
Since the method call type arguments can be inferred, it allows the use of method type inference for inferring type arguments of construing type. 
However, this solution has disadvantages like the necessary boiler-plate and prohibition of using initializers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = Create(1);

static Wrapper<T> Create<T>(T item) => new Wrapper<T>(item);
\end{lstlisting}
\caption{Workaround of constructor type inference.}
\label{img35:workaroung}
\end{figure}
\par
\info{Constructor type inference - strength of method type inference}
A possible solution would be to use method type inference in object creation expression. 
Although this solution would be simple to implement, class type parameters are more likely not to be used in constructor parameter types, which makes the method type inference useless. 
Besides that, options for inferring type arguments of construing type are not limited by not introducing breaking changes since there is no type inference at all. 
So, there is a possibility of introducing an even stronger type inference, which could be one day introduced in the method type inference when there would be a way to make breaking changes in the new compiler version. 
Figure \ref{img36:cti} shows an example of such a generic class whose all type parameters are not used in the constructor.
Because of that, extending the potential method type inference to be used in object creation expressions would be useless since the \texttt{TLogger} can’t be inferred only from parameter types.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class Algorithm<TData, TLogger> where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Use case iusing type paraemter constraints.}
\label{img36:cti}
\end{figure}
\par
\info{Constructor type inference - the first weakness solution}
Introducing improved type inference based on method type inference would solve the mentioned issues. 
Figure \ref{img37:sol1} shows a potential usage of that type inference in the first case regarding the Wrapper class where an underscore is used to represent inferred type argument. 
The inference uses the parameter type of the constructor to infer the \texttt{T} parameter type which is \texttt{int}.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<_>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{Constructor type inference: Wrapper.}
\label{img37:sol1}
\end{figure}
\par
\info{Constructor type inference - better method type inference}
Figure \ref{img38:sol2} shows a potential improvement of the type inference. 
The first statement of initializing the \texttt{alg} variable uses type inference, leveraging \texttt{TLogger}’s constraint to determine its type. 
The second statement demonstrates the possibility of having a nested underscore, which allows to more specify the type argument.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var alg = new Algorithm<_, _>(new MyData());
var algWithSpecialLogger = 
    new Algorithm<_ , SpecialLogger<_>>(new MyData());

class Algorithm<TData, TLogger> 
    where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Constructor type inference: stronger method type inference.}
\label{img38:sol2}
\end{figure}
\par
From now on, thesis calls \textit{constructor type inference} for introducing such a type inference.

\section{Requirements}

\info{intro}
This section mentions requirements that have to be fulfilled by the improvement to be likely discussed by \ac{LDM}.
\par
\info{Describe requirements given by back compatibility}
\textbf{Back compatibility} is one of the most important requirements for new language features. 
The improvement shouldn’t introduce a breaking change. However, this requirement is sometimes too strict for improvements, which would be very beneficial, and its breaking change would appear in cases that seem to be rare in the code. 
These improvements can break back compatibility by providing additional warnings or errors alerting a user of possible code behavior changes.
Figure \ref{img39:brkCh} shows an introduced breaking change when record classes were added into the C\# language. 
Before the change, the \texttt{B} identifier referred to a method without parameters and returned the \texttt{record} type. 
After the change, the \texttt{B} identifier refers to a new record type declaration. 
There is an example where the breaking change can appear when there is a type with the \texttt{record} name. 
These situations are uncommon, and the improvement benefit was big enough to be added to the language. 
The possible breaking change is notified to the user by a compilation error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class record {}
class A {
    record B(){...}
}
\end{lstlisting}
\caption{C\# record class breaking change.}
\label{img39:brkCh}
\end{figure}
\par
\info{Decribe requirements given by motivation}
\textbf{Convenience} is a key requirement to make the improvement useful. 
Regarding partial type inference, the improvement should propose a convenient way to skip ambiguous type arguments. 
The way should also be possible to use in different places where skipping type arguments could yield an advantage, like type variable declaration or casting to a different type. 
Constructor type inference should be advanced enough to cover the mentioned examples.
\par
\info{Describe requirements given by Future improvements}
\textbf{Extensibility} would make the improvement open for new features that can be needed in future language versions. 
The improvement should consider possible future improvements and not be a blocker for them.
\par
\info{Describe requirements given by Roslyn}
\textbf{Performance} is a critical section of Roslyn, which is one of the main goals of this project.
The time complexity added by the thesis’s improvement shouldn’t be too big in order to not slow the compilation process.

\section{Language feature design}

\info{Intro}
This section describes the language design of the proposed improvement. 
It discusses existing ideas of the partial type inference and combines them to form the proposed design. 
Then, it adjusts method type inference algorithm to handle partially specified type arguments and introduces constructor type inference, which extends method type inference algorithm.
\par
\info{Discuss mentioned ideas}
The mentioned ideas can be categorized into three groups. 
The first group consists of target-typed inference and type inference based on type constraints, which improve method type inference algorithm. 
The second group consists of default type parameters, generic aliases, named type parameters, using char as inferred type argument, and relocation, which regards partial type inference. 
The third group consists of constructor type inference and type inference of method return type, which introduce type inference in new C# constructs. 
Method return type inference is not in the scope of this work, although it is mentioned in the next section as a future improvement that will be difficult to implement. 
The first group is discussed in relation to constructor type inference, where potentially applied method type inference can be improved without introducing breaking changes. 
The second group is discussed in relation to partial type inference, which is an objective of the championed issue.

\subsection{Partial method type inference}

Discussions regarding partial type inference can be further divided into two groups. 
The first group provides hints in type parameter declarations, which are done by default type parameters. 
Since it has to be done in the declaration, partial type inference wouldn’t work with already existing code without adjusting it.
For this reason, the work excludes the idea.
\par
The second group provides hints through the usage. 
Generic aliases
don’t work for methods, and also, it doesn’t seem to be useful when the inferred type arguments don’t represent some common specialization of generic type.  
An example of the specialization is \texttt{StringDictionary<TValue>} mentioned in the previous chapter.
\par
Named type parameters are excluded since providing that would be an uncommon new feature that has no equivalent in other well-known languages like Java, C++, Kotlin, and Rust. 
We believe it would be confusing to introduce it to the users since it is a controversial change.
\par
Relocation doesn’t solve the problem of specifying all type arguments. 
It just compacts type argument lists into one.
\par
The last discussion regards using char as an inferred type argument, which is a core of the proposed design for the following reasons. 
It is already used in different languages, like a star in Kolin and Java or an underscore in Rust and F\#. 
So, it is more common and intentional than previously mentioned ideas. 
It introduces no or at least minimal syntax changes into the language, which makes the usage simple, and it solves the problem of specifying all type arguments.

\subsubsection{Choosing the syntax}

The choice of the syntax is based on six use cases where the expression of inferred type argument can be used or could be used in the future. 
Table \ref{table2:useCasesChar} shows examples of these usages, which identify necessary syntax requirements.
\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | } 
  \hline
  Generic method call & \texttt{Foo<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Object creation expression & \texttt{new Bar<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Variable declaration & \texttt{Bar<\{SYNTAX\}> temp = ...}\\
  \hline
  Array type & \texttt{\{SYNTAX\}[]}\\
  \hline
  Inferred type & \texttt{\{SYNTAX\}}\\
  \hline
  Inferred nullable type & \texttt{\{SYNTAX\}?}\\
  \hline
\end{tabular}
\end{center}
\caption{Use cases containing syntax for inferred type argument.}
\label{table2:useCasesChar}
\end{table}
\par
\textbf{Generic method call} use case represents a situation where the syntax is used during a generic method call.
\par
\textbf{Object creation expression} represents the usage in the construction of generic type.
\par
\textbf{Variable declaration} represents the potential usage in the variable type declaration, which is not in the scope of this work. 
However, it is a natural continuation of partial type inference extension where the inferred type arguments are determined by the surrounding context.
\par
\textbf{Array type} has a different syntax of type argument list specifying a type of the contained elements. 
The type of the elements can also be inferred, and the proposed syntax has to offer a convenient way to express an array type with the inferred element type.
\par
\textbf{Inferred type} doesn’t have to be contained only in the type argument list.
The previous chapter presented the \text{var} keyword used in the variable declaration, whose type is determined by the type of initializing value. 
C\# also offers a discard pattern \cite{online:discard} represented by an underscore, which is commonly used as a placeholder for variables that are not intentionally used in the code. 
Since type argument inference relates to that, the syntax should be at least aligned with already existing related syntax. 
The alignment will help the syntax to be naturally used without using language documentation.
\par
\textbf{Inferred nullable type} can be used to specify nullability of the inferred type which will be useful in scenarious where non-nullable and nullable code is mixed together.
\par
There are several syntax that can be used for inferred types. 
The work presents the most relevant syntax that appeared in the mentioned ideas and comments on the advantages and disadvantages for each variant.

\paragraph*{Diamond operator} is represened by a pair of two angle brackets \texttt{<>}.
It is used as an empty type argument list determining that the type name or method name is generic.
\par
Figure \ref{img40:opDi1} demonstrates the usage in generic method calls of \texttt{Foo1} and \texttt{Foo2}. 
The declarations of these methods are not important for the purpose of showing the pros and cons. 
Calling the \texttt{Foo1} method with an empty argument list doesn’t make much sense since method type inference is enabled by default without using angle brackets. 
Calling the \texttt{Foo2} method with nested usage of the diamond operator allows limited partial type inference when the diamond operator is used inside the type argument list. 
The \texttt{Bar<>} type partially hints to the compiler the generic type name without specifying the type arguments. 
However, the usage is problematic when there are multiple generic types with the same name since it can cause ambiguity between them. 
This problem is described in the next example.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<>(arg1, arg2, arg3);
Foo2<Bar<>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Diamond operator - generic method call.}
\label{img40:opDi1}
\end{figure}
\par
Figure \ref{img41:opDi2} shows the usage in object creation expression. 
The first statement containing \texttt{Bar<>} name has the advantage of expressing the will to infer the type’s type arguments, which is necessary in comparison to the previous example since the object creation doesn’t offer type inference. 
If the type inference were potentially turned on by default, it would introduce a breaking change. 
However, there is also a disadvantage of the usage since it doesn’t specify the arity of the generic type. If there were multiple generic types differing in arity, it would complicate the already mentioned overload resolution phase since all constructors from these generic types would have to be considered. The process would be computationally demanding. 
A possible solution would be the following restriction. 
Usually, there is not more than one generic type with the same name. 
So when there is just one type of that name, the diamond operator would be allowed to use it since the name determined one specific generic type. 
In the example, \texttt{Baz<>} would refer to \texttt{Baz<T1, T2>} generic type since there is no other generic type with the same name, causing the ambiguity.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
new Bar<>(...);
new Baz<>(...);

class Bar { ... }
class Bar<T1> { ... }
class Bar<T1, T2> { ... }

class Baz<T1,T2> { ... }
\end{lstlisting}
\caption{Diamond operator - object creation expression.}
\label{img41:opDi2}
\end{figure}
\par
The third example is shown in Figure \ref{img42:opDi3}, where the generic \texttt{Wrapper} class is used to specify the wrapping generic type. 
However, it doesn’t offer to specify any type arguments, which is limiting when the compiler can’t infer all of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Wrapper<> temp = ...
\end{lstlisting}
\caption{Diamond operator - variable declaration.}
\label{img42:opDi3}
\end{figure}
\par
Figure \ref{img43:opDi4} shows the operator as an indicator of the inferred element of the array type. 
Since there isn’t a known popular language similar to C\#, which would contain a similar construct, the usage is considered to be unintentional for most of the users.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
<>[] temp = ...
\end{lstlisting}
\caption{Diamond operator - array type.}
\label{img43:opDi4}
\end{figure}
\par
Similar conclusions are made in the last example in Figure \ref{img44:opDi5} where the \texttt{<>} operator has the same functionality as the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
<> temp = ...
\end{lstlisting}
\caption{Diamond operator - inferred type.}
\label{img44:opDi5}
\end{figure}
\par
The \texttt{?} nullable operator can be appended to the diamond operator.
In general, each syntax introducing a placeholder which is not a whitespace is suitable for appending the \texttt{?} operator

\paragraph*{Whitespace separated by commas} is the next proposed syntax, which would allow skipping inferred type arguments and specify just the ambiguous. 
It would also determine the arity of type, which is important for the type name look-up phase of the compiler. 
A natural choice for the separator is commas since it is widely used. 
Another advantage is that this syntax is already used when working with C\# reflaction. 
An example is the following expression \texttt{typeof(Dictionary<,>)}, which returns a class describing the \texttt{Dictionary} type.
\par
Figure \ref{img45:opW1} shows the usage when the \texttt{Foo1} generic method is called by
skipping the first and the last type argument, which is inferred by the compiler. 
However, the syntax seems to be messy when it is used in generic methods with many generic type parameters, as can be seen in the \texttt{Foo2} method call. 
Similar thoughts regard the second and third use case.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<, string, List<>, >(arg1, arg2, arg3);
Foo2<,,,int,,>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Whitespace - generic method call.}
\label{img45:opW1}
\end{figure}
\par
The usage with array type seems to be unintentional and would cause changes in the compiler parser. 
Figure \ref{img46:opW4} shows the syntax to express the inferred type of array's element.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
[] temp = ...
Foo<, [], >(arg1, arg2)
\end{lstlisting}
\caption{Whitespace - array type.}
\label{img46:opW4}
\end{figure}
\par
The last use case regarding using the whitespace as an inferred type would probably cause problems with determining declarations of variables. 
Figure \ref{img47:opW5} shows a situation where the compiler can’t determine if it is a variable declaration or a variable assignment. 
Although it could be solved by investigating the surrounding context, we consider that the code comprehension would get worse.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
temp = ...
\end{lstlisting}
\caption{Whitespace - inferred type.}
\label{img47:opW5}
\end{figure}
\par
Since there is no placeholder which will be prepended to the nullable operator, this option doesn't work well in this scenario.

\paragraph*{Underscores separated by commas} is commonly used in other programming languages like F\# or Haskell to represent inferred type arguments, or as a placeholder for discarding variables that are intentionally not used. 
This is considered as a big advantage. 
A disadvantage is the introduction of breaking change because C\# allows the underscore as a type identifier. 
However, that seems to be rather uncommon in the code. 
It seems to be less messy than the previous syntax when a generic type contains many type parameters, as shown in Figure \ref{img50:opU1}.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
new Bar<_, _, List<_>, _,_>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Underscore - object creation expression.}
\label{img50:opU1}
\end{figure}
\par
The usage with array type also seems to work even if it can still be considered uncommon. 
Figure \ref{img51:opU4} shows the usage where we think that the syntax intentionally expresses the inferred type of array’s elements.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_[] temp = ...
\end{lstlisting}
\caption{Underscore - array type.}
\label{img51:opU4}
\end{figure}
\par
The last use case is shown in Figure \ref{img52:opU5} where it clashes with the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_ temp = ...
\end{lstlisting}
\caption{Underscore - variable declaration.}
\label{img52:opU5}
\end{figure}


\paragraph*{\texttt{var} keywords separated by commas} are another natural option of the syntax. 
The big advantage of the syntax is the already used var keyword in the variable declaration, whose meaning is coherent with inferred type arguments. 
However, it starts to raise the question if it brings the advantage of saving keystrokes. 
Figure \ref{img52:opV1} shows a usage of the syntax, which is considered to be unnecessarily long.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<var, string, List<var>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{\texttt{var} - generic method call.}
\label{img52:opV1}
\end{figure}

\paragraph*{Something else separated by commas} doesn't make a lot of sense because it needs to assign new meaning to that character in comparison with an underscore, the \texttt{var} keyword, the \texttt{<>} operator, or \texttt{<,,,>} syntax. 
An asterisk can be considered.
However, it can remind a pointer in the context of unmanaged C\# code.

\paragraph*{Conslusion} The thesis chooses the underscore as a placeholder for inferred
type argument since the meaning of this character is related to the intention. 
It also seems to be the shortest and synoptical way to skip inferred type arguments. 
The possible breaking change is not an obstacle in this situation since a similar decision was made for the \texttt{var} keyword, and the situation where it can occur seems to be rare. 
Problems with the potential future extension where the underscore can represent inferred type in the variable declaration would be prohibited to not mix it with the \texttt{var} keyword. 
Although the diamond operator is not very useful in a generic method call, it makes sense in object creation expression. 
The usage and analysis of that is covered by this work as well.

\subsubsection{Method and typename lookup}

The previous section presented the proposed syntax for skipping inferred type arguments using an underscore as a placeholder. 
This section continues with determining what the expression containing the syntax exactly means.
\par
Since an underscore character is a valid type identifier in C\# and there is
1:1 mapping of inferred type arguments to these placeholders, determining the referred generic method containing the proposed syntax is almost unchanged. 
The change is in overload resolution where if the generic method is \textit{partially inferred}, meaning it contains the syntax, the type inference has to be done to determine the type arguments of that method.
\par
An underscore itself can be a nullable or non-nullable type. 
If the inferred type argument has to be a nullable type, the metioned \texttt{?} operator can be appended to the underscore. 
Figure \ref{img53:null} shows an example of using the nullable operator. 
The call of \texttt{Foo} generic method has three type arguments where the first one is inferred by the compiler and which has to be nullable. 
The second type argument is the \texttt{List} type, containing an inferred nullable type argument as well. 
The third type argument doesn’t require the nullable type, so the inferred type can be either nullable or non-nullable.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_?, List<_?>, _>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Inferring nullable type argument.}
\label{img53:null}
\end{figure}
\par
The type name lookup is also almost unchanged. 
If there is an underscore
referring to inferred type argument, it simply ignores the binding of this identifier.
\par
The underscores contained in the type arguments are threatened in the changed type inference algorithm mentioned in the following section.

\subsubsection{Method type inference algorithm change}

The thesis extends method type inference by introducing a new type variable bound which represents inferred type arguments contained in the type argument list.
Firstly, if a generic method call doesn't contain a type argument list, the method type inference is unchanged.
The change is when the generic method is partially inferred.
Figure \ref{img54:partInf} shows an example of partially inferred method \texttt{Foo} containing two type parameters.
The former algorithm identifies the type arguments as type variables for which it tries to find an unique type.
The algorithm can be extended to represent placeholders for inferred type arguments as type variables too.
Using the example, all three underscores would be represented as three unique type variables besides those representing \texttt{T1} and \texttt{T2} type parameters.
However, this extension has to also be respected by the order of type variables fixing and inferring.
A reason can be seen in \texttt{T2} type variable.
The \texttt{Dictionary<\_, \_>} can be considered as a bound for the type variable which has to be respected.
Although this bound contains another type varaibles which are not yet known.
So the algorithm has to firstly infer the type variables contained in that bound and then to infer the \texttt{T2} type variable.
The second observation for this extension is a way of inferring the bounds.
Since type variable bounds can contain another type variables, it is necessary to propagate relation between the bounds in the time of adding new bounds.
An example of this can be demonstrated using the given Figure \ref{img54:partInf}.
The \texttt{Dictionary<\_, \_>} is a bound of the \texttt{T2} type variable.
The second bound is a type of the \texttt{p2} argument.
This type gives us bounds for type variables contained the former bound which has to be propagated.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_, Dictionary<_, _>>(arg1, new Dictionary<int, int>());

void Foo<T1, T2>(T1 p1, T2 p2)
\end{lstlisting}
\caption{Partially inferred method call.}
\label{img54:partInf}
\end{figure}
\par
The proposed algorithm uses two new definitions of dependendencies which are given below.
\begin{defn}[Shape dependence]
An unfixed type variable \texttt{$X_i$} \emph{shape-depends directly} on an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} represents \textit{inferred\_type\_argument} and it is contained in shape bound of the type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{shape-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{shape-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{shape-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{shape-depends on} \texttt{$X_e$}. Thus \textit{shape-depends on} is the transitive but not reflexive closure of \textit{shape-depends directly on}.
\end{defn}
\begin{defn}[Type dependence]
An unfixed type variable \texttt{$X_i$} \textit{type-depends directly on} an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} occurs in any bound of type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{type-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{type-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{type-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{type-depends on} \texttt{$X_e$}. 
Thus \textit{type-depends on} is the transitive but not reflexive closure of \textit{type-depends directly on}.
\end{defn}
\par
The required changed of the algorithm is presented as an algorithm divided into three figures and which is based on the former method type inference.
Figure \ref{img54:mainTypeInference1} shows the beginning, the first, and second phase.
The first step is to identify all type variables which would be an objective of the type inference.
This is done by the \texttt{getAllTypeVariables} function which replaces the undescore placeholders in the provided type arguments (If the type arguments were provided) by new type variables and join them with type variables representing type parameters of the method.
\par
Besides already known three types of bound, the algorithm adds \textit{shape-bound} representing a type argument given in the type argument list.
The reason for a new type of bound is the following.
When an user provides the type argument, the algorithm should exactly infer the same type(not containing any unfixed type variables).
None of the already introduced type bounds didn't offer this feature.
An example of this need is described by a potential scenario when there is the \texttt{IList<\_>} type as a type argument.
When the compiler treats nullability, it wants the hinted type parameter to be non-nullable(not \texttt{IList<\_>?}). 
It can happen, other bounds would infer the nullable version, and although \texttt{IList<\_>} can be converted to \texttt{IList<\_>?}, it is not the user's intention.
However, the exact bound would allow this.
\par
\texttt{FirstPhase} before the initial collecting of bounds from argument list it collects shape bounds from the provided type argument list.
The referring \texttt{InferShapeBound} is described later with the rest of inferring methods.
\par
\texttt{SecondPhase} now respects new added dependencies which forces to infer type variables in the correct order.
If there is no type variables which is indenpendent, the algorithm relax the dependencies to break possible circular dependency which still has a chance to be resolved.
In comparison to the former algorithm, the relaxation still has to respect \textit{shape-depends on} relation.
The reason for that is to prohibit that inferred type would be different from the provided "shape" in the type argument list.
The next condition is that at least one bound can't contain an unfixed type variable.
This requirement is to have at least one candidate which could be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
Input: method call M<$S_1$,...$S_n$>($E_1$,...$E_x$) and 
       its signature $T_e$ M<$X_1$,...,$X_n$>($T_1$ $p_1$,...,$T_x$ $p_x$)
Output: inferred $X_1$,...$X_n$,...$X_{n+l}$
$B_{lower}$ = $B_{upper}$ = $B_{exact}$ = $B_{shape} = $F = []
$TV$ = getAllTypeVariables(X, S)
FirstPhase()
SecondPhase()
fn FirstPhase():
  S.foreach(s -> InferShapeBound(s, T[s.idx]))
  /*Continuation as the former method type inference*/
fn SecondPhase():
  while (true):
    $TV_{indep}$ = $TV$.filter(x $\rightarrow$ 
      F[x.idx] == null && $TV$.any(x $\rightarrow$ 
        dependsOn(x, y) && shapeDependsOn(x, y) 
        && typeDependsOn(x, y)
      )
    )
    $TV_{dep}$ = $TV$.filter(x $\rightarrow$
      F[x.idx] == null && $TV$.any(y $\rightarrow$ 
        (dependsOn(y, x) || shapeDependsOn(y, x) 
          || typeDependsOn(y, x)) 
        && !$TV$.any(t $\rightarrow$ shapeDependsOn(x, t))
        && ($B_{lower}$+$B_{upper}$+$B_{exact}$+$B_{shape}$).any(b $\rightarrow$ 
            !b.containsUnfixedTypeVariable
        )
      )
    )
    /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Phases of new Method Type Inference}
\label{img54:mainTypeInference1}
\end{figure}
\par
Figure \ref{img55:mainTypeInference2} shows adjusted three adjusted inferences adding new bounds and presents a new \texttt{InferShape} inference.
The change is in propagating nested type bounds between type variable bounds.
This is done by the \texttt{Propagate} function which is invoked after a new bound was added.
It iterates over all bounds of the type variable and do additional type inference for each bound containing an unfixed type variable checked by the \texttt{containsUnfixedTypeVariable} property.
This step will ensure that the unfixed type variable will receive a bound which is associate with.
Using mentioned example \ref{img54:partInf}, this phase propagates the \texttt{int} type bounds contained in the \texttt{Dictionary<int, int>} type of provided argument to the underscores representing type variables in the \texttt{Dictionary<\_ ,\_>} type argument.
Since the architecture of the algorithm always adds bounds contained in the left argument of the functions to the right argument of the function, it is needed to the inference for each transposition of the pair.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Propagate(Type U, int typeVariable) {
  setOf($B_{shape}$[typeVariable],
    $B_{lower}$[typeVariable],
    $B_{upper}$[typeVariable],
    $B_{exact}$[typeVariable]
  ).foreach(b $\rightarrow$
    if (b.containsUnfixedTypeVariable) InferHelper(U, b)
    if (U.containsUnfixedTypeVariable) InferHelper(b, U)
  )
}

fn InferExact(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{exact}$[t.idx].contains(U)) {
    $B_{exact}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferLower(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{lower}$[t.idx].contains(U)) {
    $B_{lower}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferUpper(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{upper}$[t.idx].contains(U)) {
    $B_{upper}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferShape(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null)) {
    $B_{shape}$[t.idx] = U
    Propagate(U, t.idx)
  }
\end{lstlisting}
\caption{\textit{Exact inference}, \textit{Upper-bound inference}, \textit{Lower-bound inference}, \textit{Shape-bound inference}}
\label{img55:mainTypeInference2}
\end{figure}
\par
Table \ref{table3:InferHelper} shows which inference is called based on the inputs.
For example, if the \texttt{U} represents added lower bound and b is a exact bound, the algorithm calls \texttt{InferUpper} inference based.
Intuation behing the table is to respecting bounds reletation between bounds of a type variable.
So for example, all bounds of lower bounds are lower bounds for exact, upper and shape bounds of that type variable, and are exact bounds for each other.
\begin{table}[h!]
\begin{center}
\begin{tabular}{ | c | c | c | c | c | } 
  \hline
   & Lower & Upper & Exact & Shape\\
  \hline
  Lower & InferExact  &  InferUpper & InferUpper & InferLower \\
  \hline
  Upper & InferLower  &  InferExact & InferLower & InferLower \\
  \hline
  Exact & InferLower  &  InferUpper & InferExact & InferExact \\
  \hline
  Shape & InferLower  &  InferUpper & InferExact & InfeExact \\
  \hline
\end{tabular}
\end{center}
\caption{Matrix of \texttt{InferHelper} function.}
\label{table3:InferHelper}
\end{table}
\par
Figure \ref{img55::mainTypeInference3} shows last part of the changed algorithm, type variable fixation.
The set of candidates is changed to respect shape bound ability to express exact form of the inferred type argument.
So if the type variable contains a shape bound, the candidate list contains only this type and other bounds are used to check if the candidate doesn't contradicts with collected bounds.
There are two notes regarding this step.
If there is a shape bound, it doesn't contain any unfixed type variables because of the condition in the second phase.
Hence it will be a valid type argument.
It can happen, that some bounds will contain unfixed type variables.
In this case, these bounds are removed from the checking and candidates.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Fix(TypeVariable x):
  $U_{candidates}$ = 
  if ($B_{shape}$[x.idx] != null)
    setOf($B_{shape}$[x.idx])
  else
    ($B_{lower}$[x.idx] + $B_{upper}$[x.idx] + $B_{exact}$[x.idx]).filter(b $\rightarrow$
        !b.containsUnfixedTypeVariable
    )
  /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Fixing of type variables}
\label{img55::mainTypeInference3}
\end{figure}
\par
The last observation is ensure that the propagation will end.
Since we doesn't add the same bound multiple times, the cycle can't occur.

\subsection{Partial constructor type inference}

TODO

\subsubsection*{Class lookup}

TODO

\subsubsection*{Constructor type inference}

TODO

\subsubsection*{Initiliazers extension}

TODO

\subsubsection*{Diamond operator extension}

TODO

\change{Explain why they fullfill the requirements}

TODO

\subsection{Partial time inferece during dynamic member invocation}

TODO

\section{Other type inference improvements}

TODO

\change{Shared type inference context}

TODO

\change{Inferring return value of methods}

TODO