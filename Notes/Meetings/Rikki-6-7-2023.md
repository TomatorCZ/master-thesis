# Meeting notes

## What to discuss

- Show a prototype enabling constructor type inference + new method type inference, show tests
- Show current prototype, bounding type inferred arguments
- Present a way how to accomplish type inference of constructor including initializer lists, new type inferrer,...

### Previous prototype

- Added a new syntax node for inferred type argument -> It required to change the language parser (Bad idea)
- Then I handled the syntax in Binder and created `SourceInferredTypeArgument`
- Then I changed the type inferrer to be able to handle arbitrary set of constraints and enabling to infer the inferred type arguments and type parameters
- I added a new type of bound `Shape` prohibiting to merge it with another type(It was problem of `Exact` bound when nullable occured).
- I added new constraints describing provided type arguments. It implied that bounds could contain type variables (`SourceInferredTypeArgument`)
- So I added new dependencies track this fact. And respected it during the fixing
- I modified adding a new bound. When the added bound contained type variable or type variable was contained in already presented bounds -> we did an inference of these pairs.
- Then I changed binding of a class constructor and constructor overload resolution to employ the new type inferrer.
- During nullability check, we had to add warning that type inference failed when nullable constraints were not satisfied. Because the current state is the following. When the type inferrer fails in the nullable walker, no warning is raised. Potential issues with nullability are announced during cheking the assignment of arguments to parameters.

What issues we found?

- `_` placeholder can appear as a type name -> We didn't respect that
- The inferrer was not ready for adding new constraints because the second phase depends on already fixed values which can be changed by new constraints.

### Current prototype

- We used the same way as in `var` keyword. That means if we are in the situation(type argument list of method invocation or constructor) where `_` can be considered as a inferred type argument, we will do a lookup for that type name, if there is nothing, we will consider `_` be a inferred type argument. 
- To be able to use the type inference multiple times, we want these features from type inferrer
  - It is able to do snapshots for rollbacking
  - It does the second phase only on demand because the second phase depends on fixed results.
  - It is able to add new constraints and type variables
  - It is able to check if the constaints holds, and if not, it can distinguish it. (constraint (int == string) shouldn't be valid, but in the current state, the inferrer doesn't care about it in the first phase). The current type inferred just seeked for the bounds and then check the inferred type only against the bounds.
  - It needs be able to handle type variables in bounds -> we need to adjust adding new bounds, and doing infernece.
- We need to change binding of creation expression...

### Alternative

- Collect just constraints and invoke the inference repeatedly.
  - A lot of redundant work
  - Doesn't solve the problem with checking the constraints

> Invocation expression binding

![InvocationExpressionBinding](../Artifacts/InvocationExpressionBinding.drawio.png)

> Constructor expression binding

![ConstructorExpressionBinding](../Artifacts/ObjectCreationExpressionBinding.drawio.png)

> Method type inference

![MethodTypeInference](../Artifacts/MethodTypeInferrer.drawio.png)

> Improved invocation expression binding

![ImprovedInvocationExpressionBinding](../Artifacts/InvocationExpressionBinding_Improved.drawio.png)

> Improved constructor expression binding

![ImprovedConstructorExpressionBinding](../Artifacts/ObjectCreationExpressionBinding_Improved.drawio.png)

> Improved method type inference 

> ![ImprovedMethodTypeInference](../Artifacts/MethodTypeInferrer_Improved.drawio.png)