\chapter{Problem analysis}
\info{Describe the chapter}
The chapter divides the analysis into four sections. 
The first section describes the scope of the improvement based on the mentioned championed issue recommended by \ac{LDT}. 
The second section mentions a concrete motivation which leads us to the proposed improvement. 
The third section determines requirements based on the motivation, requirements given by proposing new language features, and Roslyn implementation internals. 
The fourth section describes the proposed language feature design, which is inspired by C\# language feature ideas mentioned in the previous chapter and validated by the requirements.
The last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements. 

\section{Scope}
\info{Describe why we choose only a small part of the C\# type inference}
The previous chapter indicates that type inference is a complicated process, where even the current C\# method type inference is difficult to understand. 
Hence, the thesis chooses a small part of C\# where it improves and introduces the type inference and would be possible to reason about and implement in the scope of this text. 
The second reason for choosing a minor change is that introducing a completely new type inference in C\# would rather have an experimental result, which would have a smaller chance of getting into production, which is different from the intention of this work. 
However, some more extensive changes in the type inference will also be mentioned to outline possible obstacles to introducing them in the C\#.
\par
\info{Specify the focus on partial type inference}
The thesis focuses on the already-mentioned \textit{partial type inference} proposal, which was recommended by a member of \ac{LDT} and has a chance to be discussed in \ac{LDM} and potentially accepted. 
Analysis of this improvement contains a consideration of existing ideas, their consequences on C\#, and their difficulties in implementing them in Roslyn. 
Additionally, the work describes the relation to the Hindley-Millner formalization to express the strength of the type inference in a formalized way, which can be further used to compare it with other kinds of type inference in different programming languages and which decides the theoretical boundaries of the C\# type inference.

\section{Motivation}
\info{What is partial type inference and why it is useful}
Partial type inference focuses on hinting to the compiler ambiguous type arguments of generic type or method in situations where it can’t deduce them. 
In the context of C\#, the only type inference that infers type arguments is the method type inference mentioned in the previous chapter. 
The weakness of the method type inference is the need to provide hints to the compiler. 
The following three real-world examples demonstrate common issues with method type inference weakness, which the thesis tries to solve.
\par
\info{Weakness of current method type inference - target typing}
The first weakness regards target typing, which was mentioned in the previous chapter. 
Suppose a hypothetical situation when a user queries an item from a database whose column is a point of interest. 
Figure \ref{img27:usecase1} shows an example of code that uses the \texttt{fetch} method defined on a database type. 
The \texttt{data} variable represents data fetched from a database. 
Since a concrete form of data is unknown, the data has the type of \texttt{object} containing an internal representation of fetched data with the columns stored as fields. 
The \texttt{GetField} method enables one to read the variable’s field of the given name with the supposed type given as a type argument. 
Suppose the fetched object contains the ”name” field containing a string value. 
Now, a user wants to store the value in the \texttt{name} variable, which is explicitly typed. 
Even though the return type of the \texttt{GetField} method is known from the variable declaration, which also is the \texttt{TReturn} type argument of the method, the user still has to specify the type argument in the call. 
Generally, this problem consists of all type inferences, which depend on the target type. The target can be an argument of another method call or an assigning field. 
If the method type inference considers the target type, the user will not have to specify the \texttt{string} type argument in the \texttt{GetField} call.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
object data = database.fetch();
string name = data.GetField<string>("name");
...
static class Extensions {
    static 
    TReturn GetField<TReturn>(this object inst, string fieldName) 
    {...}
}
\end{lstlisting}
\caption{Target-typed inference.}
\label{img27:usecase1}
\end{figure}
\par
\info{Weakness of current method type inference - Constraints-based inference}
The second weakness is noticeable in more advanced generic APIs, like testing frameworks, using type constraints containing the type parameters. 
Figure \ref{img28:usecase2} shows a scenario of a simple test framework that defines the \texttt{Test} method parameterized by a type of input data and test case represented as type parameters \texttt{U} and \texttt{V}, respectively. 
The providing type argument representing the test case has to inherit the \texttt{TestCaseBase} base implementation, which is a generic type parametrized by a type of input data. 
This constraint gives type information about the \texttt{T} type parameter, which is related to the type of input data. 
However, the user has to specify type arguments in the \texttt{Test} call since the type inference doesn’t consider this source of type information. 
If the compiler considers the constraint, the type arguments will be inferred, saving the type annotations.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Test<TestCaseBase<MyData>, MyData>(new MyData());
...
void Test<T, U>(U data) where T : TestCaseBase<U> {...}
\end{lstlisting}
\caption{Constraints-based inference.}
\label{img28:usecase2}
\end{figure}
\par
\info{Weakness of current method type inference - all or nothing principle}
There are also situations where even strong type inference is not enough.
Figure \ref{img29:usecase3} shows a situation where the \texttt{log} method is parametrized by two type parameters that are obtained in the parameter types and hence inferable by the compiler. 
However, the \texttt{log} method call still has to specify type arguments because the \texttt{null} argument doesn’t have concrete type information. 
In this case, the user always has to specify the second type argument, but the compiler can infer the first type argument. 
The thesis refers to this problem as \textit{all or nothing} principle, which regards the obligation to specify all type arguments or none of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<Message, Appendix>(new Message(...), null);
...
void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Uninferable type argument.}
\label{img29:usecase3}
\end{figure}
\par
\info{Breaking changes - Possible improvement of method type inference}
The first and the second weaknesses motivate us to extend the method type inference in order to consider a wider context for obtaining type information for the type arguments. 
This potential improvement is a problem for the compiler's back compatibility which was mentioned in the C\# discussion \cite{online:breakingChange}. 
New compiler versions should be back-compatible so that a new version does not change the behavior of the code compiled by the older version.
\par
\info{Breaking changes - target-typing}
Figure \ref{img30:breakingChange1} shows the breaking change when method type inference starts to consider target types. 
Before the improvement, the \texttt{M} method call is resolved to the non-generic version of this method because type inference can’t infer the \texttt{T} type argument. 
After the improvement, the type inference infers \texttt{T} to be the \texttt{int} type, which is more specific to the type of \texttt{1} argument than the \texttt{long} type. 
So now, the \texttt{M} method call refers to the generic version of this method and executes different code without any warning or error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
int name = M(1);
...
T M<T>(int p1) {...}
int M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Target-typed inference.}
\label{img30:breakingChange1}
\end{figure}
\par
\info{Breaking changes - Constraints-based inference}
Figure \ref{img31:breakingChange2} shows a similar situation when the method type inference starts to consider type parameter constraints. 
Before the improvement, the \texttt{M} method call refers to the non-generic version of the method since the type inference can’t infer the type argument of a generic version. 
After the improvement, the generic version is inferred to have the \texttt{int} type argument and becomes to be more suitable for the overload resolution. 
So, the code behavior changed again because of compiling it with a different compiler's version.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
M(1);
...
void M<T>(int p1) where T : List<int> {...}
void M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Constraints-based inference.}
\label{img31:breakingChange2}
\end{figure}
\par
\info{Possible method type inference improvement doesn't solve the third weakness}
Besides the breaking change, the potential method type inference improvement to use a bigger context still doesn’t solve our third example demonstrating a type parameter, which doesn’t appear in parameter types, return type, and the type parameters’ constraints. 
These obstacles give the reason for introducing a way to hint just ambiguous type arguments to the compiler.
\par
\info{Partial type inference - reduces the first and second weakness}
Partial type inference can reduce the first two weaknesses. 
Type arguments, which the method type inference can’t infer, can be hinted in order to avoid specifying the whole type argument list. 
Let’s now ignore why the underscore character is used and how inferred type variables are determined in the following example. 
The reasons behind that will be mentioned later.
Figure \ref{img32:sol1} shows the usage of partial type inference applied in the second presented example regarding method type inference weaknesses. 
Although the first type argument of the \texttt{Test} method call must still be provided, the second argument is omitted by using the underscore character to determine an inferred type argument. 
The reduction of the first weakness is to isolate the insufficient type inference to type arguments that are directly influenced by it and infer the rest.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
test<TestCaseDefault<MyData>, _>(new MyData());

void test<T, U>(U data) where T : TestCaseDefault<U> {...}
\end{lstlisting}
\caption{Partial type inference: Reducing method type inference weakness.}
\label{img32:sol1}
\end{figure}
\par
\info{Breaking changes - solves the third weakness}
The third motivation example confirms that partial type inference is not just a fix for missing type inference features but is needed when type arguments can’t be inferred at all. 
Figure \ref{img33:sol2} demonstrates a usage of partial type inference where it omits the first type argument since it can be deduced from the first argument type and specifies the ambiguous type that can’t be deduced.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<_, Appendix>(new Message(...), null);

void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Partial type inference: Solving the \textit{all or nothing} problem.}
\label{img33:sol2}
\end{figure}
\par
\info{Constructor type inference - next motivation and improvement}
Partial type inference doesn’t regard only method type inference. 
It can also be introduced in other places. One of the places that seems to be good for that is object creation expression. 
Except for the already mentioned \texttt{new()} operator, no other type inference infers type arguments of a construing generic type. The usage of the type inference is limited since the \texttt{new()} operator requires a target type to infer the construing type. 
Figure \ref{img34:wrapper} shows an example of the limitation, where the \texttt{new()} operator can’t be used since the \texttt{IWrapper} target type is not the \texttt{Wrapper<int>} construing type. 
Hence, the user has to specify the whole type with the \texttt{int} type argument, despite the fact that it could be inferred using method type inference.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<int>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{C\# wrapper class.}
\label{img34:wrapper}
\end{figure}
\par
\info{Constructor type inference - Factory method workaround}
In principle, object creation can be considered a special case of a method call with a side effect(creating the object), which already has method type inference. 
Figure \ref{img35:workaroung} shows a workaround using the \texttt{Create} method, delegating the creation to the constructor call. 
Since the method call type arguments can be inferred, it allows the use of method type inference for inferring type arguments of construing type. 
However, this solution has disadvantages like the necessary boiler-plate and prohibition of using initializers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = Create(1);

static Wrapper<T> Create<T>(T item) => new Wrapper<T>(item);
\end{lstlisting}
\caption{Workaround of constructor type inference.}
\label{img35:workaroung}
\end{figure}
\par
\info{Constructor type inference - strength of method type inference}
A possible solution would be to use method type inference in object creation expression. 
Although this solution would be simple to implement, class type parameters are more likely not to be used in constructor parameter types, which makes the method type inference useless. 
Besides that, options for inferring type arguments of construing type are not limited by not introducing breaking changes since there is no type inference at all. 
So, there is a possibility of introducing an even stronger type inference, which could be one day introduced in the method type inference when there would be a way to make breaking changes in the new compiler version. 
Figure \ref{img36:cti} shows an example of such a generic class whose all type parameters are not used in the constructor.
Because of that, extending the potential method type inference to be used in object creation expressions would be useless since the \texttt{TLogger} can’t be inferred only from parameter types.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class Algorithm<TData, TLogger> where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Use case iusing type paraemter constraints.}
\label{img36:cti}
\end{figure}
\par
\info{Constructor type inference - the first weakness solution}
Introducing improved type inference based on method type inference would solve the mentioned issues. 
Figure \ref{img37:sol1} shows a potential usage of that type inference in the first case regarding the Wrapper class where an underscore is used to represent inferred type argument. 
The inference uses the parameter type of the constructor to infer the \texttt{T} parameter type which is \texttt{int}.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<_>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{Constructor type inference: Wrapper.}
\label{img37:sol1}
\end{figure}
\par
\info{Constructor type inference - better method type inference}
Figure \ref{img38:sol2} shows a potential improvement of the type inference. 
The first statement of initializing the \texttt{alg} variable uses type inference, leveraging \texttt{TLogger}’s constraint to determine its type. 
The second statement demonstrates the possibility of having a nested underscore, which allows to more specify the type argument.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var alg = new Algorithm<_, _>(new MyData());
var algWithSpecialLogger = 
    new Algorithm<_ , SpecialLogger<_>>(new MyData());

class Algorithm<TData, TLogger> 
    where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Constructor type inference: stronger method type inference.}
\label{img38:sol2}
\end{figure}
\par
From now on, thesis calls \textit{constructor type inference} for introducing such a type inference.

\section{Requirements}

\info{intro}
This section mentions requirements that have to be fulfilled by the improvement to be likely discussed by \ac{LDM}.
\par
\info{Describe requirements given by back compatibility}
\textbf{Back compatibility} is one of the most important requirements for new language features. 
The improvement shouldn’t introduce a breaking change. However, this requirement is sometimes too strict for improvements, which would be very beneficial, and its breaking change would appear in cases that seem to be rare in the code. 
These improvements can break back compatibility by providing additional warnings or errors alerting a user of possible code behavior changes.
Figure \ref{img39:brkCh} shows an introduced breaking change when record classes were added into the C\# language. 
Before the change, the \texttt{B} identifier referred to a method without parameters and returning the \texttt{record} type. 
After the change, the \texttt{B} identifier refers to a new record type declaration. 
There is an example where the breaking change can appear when there is a type with the \texttt{record} name. 
These situations are uncommon, and the improvement benefit was big enough to be added to the language. 
The possible breaking change is notified to the user by a compilation error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class record {}
class A {
    record B(){...}
}
\end{lstlisting}
\caption{C\# record class breaking change.}
\label{img39:brkCh}
\end{figure}
\par
\info{Decribe requirements given by motivation}
\textbf{Convenience} is a key requirement to make the improvement useful. 
Regarding partial type inference, the improvement should propose a convenient way to skip ambiguous type arguments. 
The way should also be possible to use in different places where skipping type arguments could yield an advantage, like type variable declaration or casting to a different type. 
Constructor type inference should be advanced enough to cover the mentioned examples.
\par
\info{Describe requirements given by Future improvements}
\textbf{Extensibility} would make the improvement open for new features that can be needed in future language versions. 
The improvement should consider possible future improvements and not be a blocker for them.
\par
\info{Describe requirements given by Roslyn}
\textbf{Performance} is a critical section of Roslyn, which is one of the main goals of this project.
The time complexity added by the thesis’s improvement shouldn’t be too big in order to not slow the compilation process.

\section{Language feature design}

\info{Intro}
This section describes the language design of the proposed improvement.
It discusses existing ideas of the partial type inference, and combines them to form the proposed design.
Than, it adjusts method type inference algorithm to handle partially defined type arguments and introduces constuctor type inference extending method type inference.
\par
\info{Discuss mentioned ideas}
Mentioned ideas can be categorized into 3 groups.
The first group consists of target-typed inference and type inference based on type constraints which improve method type inference algorithm.
The second group consists of default type parameters, generic aliases, named type parameters, using char as inferred type argument, and realocation which reagrds partial type inference.
the third group consists of constructor type inference and type inferecne of method return type which introduce type inference in new C\# constructs.
Method return type inference is not in the scope of this work, although it is mentioned in the next section as a future improvement which will be difficult to implement.
The first group is discussed in relation to constructor type inference where pottentially applied method type inferance can be improved without introducing breaking changes.
The second group is discussed in relation to partial type inference which is an objective of the campioned issue.

\subsection{Partial method type inference}

Discussions regarding partial type inference can be further divided into two groups.
The first group provides the hints in type parameter declarations which is done by default type parameters.
Since it has to be done in the declaration, partial type inferenec wouldn't work with already existing code without adjusting it.
For this reason, the work excludes the idea.
\par
The second group provides the hints through the usage.
Generic aliases doesn't work for methods and also it doesn't seem to be useful when the inferred type arguments doesn't represent some common specialization of generic type which can be used example of \texttt{StringDictionary<TValue>}.
\par
Named type parameters are excluded since providing that woudl be uncommon new feature which has no equivalent in other well-known languages like Java, C++, Kotlin, and Rust.
We believe it would be confusing to introduce it to the users since it is controversial change.
\par
Realocation doesn't sovle the problem with specifying all type arguments and it just compacts type argument lists into one.
\par
The last discussing regards unsing char as inferred type argument which is a core of the proposed design for the following reasons.
It is already used in different languages like a star in Kolin and Java or an underscore in Rust and F\#.
So it is more common and intentional then previously mentioned ideas.
It introduces no or at least minimal syntax changes into the language which makes the usage simple.
And it sovles the the problem with specifying all type arguments.

\subsubsection{Choosing the syntax}

The choice of the syntax is based on five use cases where the expression of inferred type argument can be used or could be used in the future.
Table \ref{table2:useCasesChar} shows examples of these usages which identify necessary requirements on the syntax.
\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | } 
  \hline
  Generic method call & \texttt{Foo<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Object creation expression & \texttt{new Bar<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Variable declaration & \texttt{Bar<\{SYNTAX\}> temp = ...}\\
  \hline
  Array type & \texttt{\{SYNTAX\}[]}\\
  \hline
  Inferred type & \texttt{\{SYNTAX\}}\\
  \hline
\end{tabular}
\end{center}
\caption{Use cases containing syntax for inferred type argument.}
\label{table2:useCasesChar}
\end{table}
\par
\textbf{Generic method call} use case represents a situation where the syntax is used during a generic method call.
\par
\textbf{Object creation expression} represents the usage in construction of generic type.
\par
\textbf{Variable declaration} represents the potential usage in variable type declaration which is not in the scope of this work, however it is natural continuation of partial type inference extension where the inferred type arguments are deremined by the surrounding context.
\par
\textbf{Array type} has a different syntax of type argument list specifying a type of the contained elements.
The type of the elements can be also inferred and the proposed syntax has to offer convenient way how to express an array type with the inferred element type.
\par
\textbf{Inferred type} doesn't have to be contained only in the type argument list.
The previous chapter presented the \text{var} keyword used in the variable declaration whose type is determined by the type of initializing value.
C\# also offers a discard pattern \cite{online:discard} represented by an underscore which is commonly used as placeholders for variables which are not intentionally used in the code.  
Since type argument inference relates to that, the syntax should be at least aligned with already existing related syntax.
The allignment will help the syntax to be naturally used without using a language documentation.
\par
There are several syntax which can be used for inferred type.
The work presents the most relavent syntax which appeared in the mentioned ideas and comments on advantages and disadvantages for the each of them.

\paragraph*{Diamond operator} is represened by pair of two angle brackets \texttt{<>}.
It is used as empty type argument list determining that the type name or method name is generic.
\par
Figure \ref{img40:opDi1} demonstrates the usage in generic method calls of \texttt{Foo1} and \texttt{Foo2}.
The declarations of these methods are not important for the purpouse of showing pros and cons.
Calling the \texttt{Foo1} method with an empty argument list doesn't much make sense since method type inference is enabled by default without using angle brackets.
Calling the \texttt{Foo2} method with nested usage of diamond operator allows limited partial type inference when the diamond operator is used inside the type argument list.
The \texttt{Bar<>} type partially hint the compiler the generic type name without specifying the type arguments.
However, the usage is problemeatic when there is multiple generic types with the same name since it can cause ambiguity between them.
This problem is described in the next example.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<>(arg1, arg2, arg3);
Foo2<Bar<>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Diamond operator - generic method call.}
\label{img40:opDi1}
\end{figure}
\par
Figure \texttt{img41:opDi2} shows the usage in object creation expression.
The first statement containing \texttt{Bar<>} name has an advantage of expressing the will to infer the type's type arguments which is necessary in comparison the previous example since the object creation doesn't offer type inference.
If the type inference would be potentially turned on by default, it would introduce a breaking change.
Alhought, there is also an disadvantage of the usage since it doesn't specify the arity of the generic type.
If there would be multiple generic types diferring in arity, it would complicate the already mentioned overload resolution phase since all constructors from these generic types would have to be considered.
The process would be computationally demanding.
Possible solution would be the following restriction. 
Usually, there is not more than one generic type with the same name. 
So when there will be just one type of that name, the diamond operator would be allowed to use since it determined one specific generic type.
In the example, \texttt{Baz<>} would refer to \texttt{Baz<T1, T2>} generic type since there is no other generic type with the same name causing the ambiguity.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
new Bar<>(...);
new Baz<>(...);

class Bar { ... }
class Bar<T1> { ... }
class Bar<T1, T2> { ... }

class Baz<T1,T2> { ... }
\end{lstlisting}
\caption{Diamond operator - object creation expression.}
\label{img41:opDi2}
\end{figure}
\par
The third example is shown in Figure \ref{img42:opDi3}, where the generic \texttt{Wrapper} class is used to specify the wrapping generic type.
However, it doesn't offer to specify any type arguments which is limiting when the compiler can't infer all of them..
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Wrapper<> temp = ...
\end{lstlisting}
\caption{Diamond operator - variable declaration.}
\label{img42:opDi3}
\end{figure}
\par
Figure \ref{img43:opDi4} shows the operator as a indicator of inferred element of the array type.
Since there isn't known popular language similar to C\# which would contain the similar construct, the usage is considered to be unintentiaonal for the most of the users.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
<>[] temp = ...
\end{lstlisting}
\caption{Diamond operator - array type.}
\label{img43:opDi4}
\end{figure}
\par
The similar conslusions are made in the last example in Figure \ref{img44:opDi5} where the \texttt{<>} operator has the same functionality as already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
<> temp = ...
\end{lstlisting}
\caption{Diamond operator - inferred type.}
\label{img44:opDi5}
\end{figure}

\paragraph*{Whitespace seperated by commas} is the next proposing syntax which would allow to skip inferred type arguments and specify just the amigious.
It would also determine the arity of type which is important for the type name look up phase of the compiler.
Natural choice for the separator is commas since it is widely used.
Another advantage is that this syntax is already used when working with C\# reflaction.
An example is the following expression \texttt{typeof(Dictionary<,>)} which returns a class describing the \texttt{Dictionary} type.
\par
Figure \ref{img45:opW1} shows the usage when the \texttt{Foo1} generic method is called with skipping the first and the last type argument which is inferred by the compiler.
However, the syntax seems to be messy when it is used in generic methods with many generic type parameters as can be seen in the \texttt{Foo2} method call.
The similar thoughs regard the second and third use case.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<, string, List<>, >(arg1, arg2, arg3);
Foo2<,,,int,,>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Whitespace - generic method call.}
\label{img45:opW1}
\end{figure}
\par
The usage with array type seems to be unintantianal and would caused changes in the compiler parser. 
Figure \ref{img46:opW4} shows the syntax to express inferred type of array's element. 
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
[] temp = ...
Foo<, [], >(arg1, arg2)
\end{lstlisting}
\caption{Whitespace - array type.}
\label{img46:opW4}
\end{figure}
\par
The last use case regarding using the whitespace as a inferred type would probable caused problems with determining declarations of variables.
Figure \ref{img47:opW5} shows a situation where the compiler can't determine if it is a variable declaration or an variable assignment.
Although it could be solved by investigating surronding context, we consider that the code comprehension would get worse.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
temp = ...
\end{lstlisting}
\caption{Whitespace - inferred type.}
\label{img47:opW5}
\end{figure}

\paragraph*{Underscores seperated by commas} is commonly used in other programming languages like F\# or Haskell to represent inferred type arguments or as a placeholder for discarding variables wich are intentianolly not used.
This is considered as a big advantage.
An disadvantage is the introduction of breaking change because C\# allows the underscore as a type identifier.
However, that seems to be rather uncommon in the code. 
It seems to be less messy then previous syntax when a generic type contains many type parameters as it is shown in Figure \ref{img50:opU1}.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
new Bar<_, _, List<_>, _,_>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Underscore - object creation expression.}
\label{img50:opU1}
\end{figure}
\par
The usage with array type also seems to work even it can be still considered uncommon.
Figure \ref{img51:opU4} shows the usage where we think that the syntax intentianally express the inferred type of array's elements.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_[] temp = ...
\end{lstlisting}
\caption{Underscore - array type.}
\label{img51:opU4}
\end{figure}
\par
The last use case is shown in Figure \ref{img52:opU5} where it clashes with already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_ temp = ...
\end{lstlisting}
\caption{Underscore - variable declaration.}
\label{img52:opU5}
\end{figure}

\paragraph*{\texttt{var} keywords seperated by commas} are another natural option of the syntax.
The big advantage of the syntax is already used \texttt{var} keyword in the variable declaration which meaining is coherent with inferred type arguments.
However, it starts to raise the question if it brings the advantage of saving keystrokes.
Figure \ref{img52:opV1} shows an usage of the syntax which is considered to be unnecessary long.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo<var, string, List<var>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{\texttt{var} - generic method call.}
\label{img52:opV1}
\end{figure}

\paragraph*{Something else seperated by commas} doesn't make a lot of sense because it needs to assign new meaning to that character in comparison with an underscore, the \texttt{var} keyword, the \texttt{<>} operator, or \texttt{<,,,>} syntax. An asterisk can be considered, however, it can remind a pointer in the context of unmanaged C\# code.

\paragraph*{Conslusion}
TODO
%The work prefers underscore character.
%Additionally to that, It would prohibit using  underscore in the same places as \texttt{var}.

\subsubsection{Method lookup}

TODO

\subsubsection{Method type inference algorithm change}

TODO

\subsection{Partial constructor type inference}

TODO

\subsubsection*{Class lookup}

TODO

\subsubsection*{Constructor type inference}

TODO

\subsubsection*{Initiliazers extension}

TODO

\subsubsection*{Diamond operator extension}

TODO

\change{Explain why they fullfill the requirements}

TODO

\section{Other type inference improvements}

TODO

\change{Shared type inference context}

TODO

\change{Inferring return value of methods}

TODO