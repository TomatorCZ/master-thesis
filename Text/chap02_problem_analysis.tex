\chapter{Problem analysis}
\info{Describe the chapter}
The chapter divides the analysis into four sections. 
The first section describes the scope of the improvement based on the mentioned championed issue recommended by \ac{LDT}. 
The second section mentions a concrete motivation which leads us to the proposed improvement. 
The third section determines requirements based on the motivation, requirements given by proposing new language features, and Roslyn implementation internals. 
The fourth section describes the proposed language feature design, which is inspired by C\# language feature ideas mentioned in the previous chapter and validated by the requirements.
The last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements. 

\section{Scope}
\info{Describe why we choose only a small part of the C\# type inference}
The previous chapter indicates that type inference is a complicated process, where even the current C\# method type inference is difficult to understand. 
Hence, the thesis chooses a small part of C\# where it improves and introduces the type inference and would be possible to reason about and implement in the scope of this text. 
The second reason for choosing a minor change is that introducing a completely new type inference in C\# would rather have an experimental result, which would have a smaller chance of getting into production, which is different from the intention of this work. 
However, some more extensive changes in the type inference will also be mentioned to outline possible obstacles to introducing them in the C\#.
\par
\info{Specify the focus on partial type inference}
The thesis focuses on the already-mentioned \textit{partial type inference} proposal, which was recommended by a member of \ac{LDT} and has a chance to be discussed in \ac{LDM} and potentially accepted. 
Analysis of this improvement contains a consideration of existing ideas, their consequences on C\#, and their difficulties in implementing them in Roslyn. 
Additionally, the work describes the relation to the Hindley-Millner formalization to express the strength of the type inference in a formalized way, which can be further used to compare it with other kinds of type inference in different programming languages and which decides the theoretical boundaries of the C\# type inference.

\section{Motivation}
\info{What is partial type inference and why it is useful}
Partial type inference focuses on hinting to the compiler ambiguous type arguments of generic type or method in situations where it can’t deduce them. 
In the context of C\#, the only type inference that infers type arguments is the method type inference mentioned in the previous chapter. 
The weakness of the method type inference is the need to provide hints to the compiler. 
The following three real-world examples demonstrate common issues with method type inference weakness, which the thesis tries to solve.
\par
\info{Weakness of current method type inference - target typing}
The first weakness regards target typing, which was mentioned in the previous chapter. 
Suppose a hypothetical situation when a user queries an item from a database whose column is a point of interest. 
Figure \ref{img27:usecase1} shows an example of code that uses the \texttt{fetch} method defined on a database type. 
The \texttt{data} variable represents data fetched from a database. 
Since a concrete form of data is unknown, the data has the type of \texttt{object} containing an internal representation of fetched data with the columns stored as fields. 
The \texttt{GetField} method enables one to read the variable’s field of the given name with the supposed type given as a type argument. 
Suppose the fetched object contains the ”name” field containing a string value. 
Now, a user wants to store the value in the \texttt{name} variable, which is explicitly typed. 
Even though the return type of the \texttt{GetField} method is known from the variable declaration, which also is the \texttt{TReturn} type argument of the method, the user still has to specify the type argument in the call. 
Generally, this problem consists of all type inferences, which depend on the target type. The target can be an argument of another method call or an assigning field. 
If the method type inference considers the target type, the user will not have to specify the \texttt{string} type argument in the \texttt{GetField} call.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
object data = database.fetch();
string name = data.GetField<string>("name");
...
static class Extensions {
    static 
    TReturn GetField<TReturn>(this object inst, string fieldName) 
    {...}
}
\end{lstlisting}
\caption{Target-typed inference.}
\label{img27:usecase1}
\end{figure}
\par
\info{Weakness of current method type inference - Constraints-based inference}
The second weakness is noticeable in more advanced generic APIs, like testing frameworks, using type constraints containing the type parameters. 
Figure \ref{img28:usecase2} shows a scenario of a simple test framework that defines the \texttt{Test} method parameterized by a type of input data and test case represented as type parameters \texttt{U} and \texttt{V}, respectively. 
The providing type argument representing the test case has to inherit the \texttt{TestCaseBase} base implementation, which is a generic type parametrized by a type of input data. 
This constraint gives type information about the \texttt{T} type parameter, which is related to the type of input data. 
However, the user has to specify type arguments in the \texttt{Test} call since the type inference doesn’t consider this source of type information. 
If the compiler considers the constraint, the type arguments will be inferred, saving the type annotations.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Test<TestCaseBase<MyData>, MyData>(new MyData());
...
void Test<T, U>(U data) where T : TestCaseBase<U> {...}
\end{lstlisting}
\caption{Constraints-based inference.}
\label{img28:usecase2}
\end{figure}
\par
\info{Weakness of current method type inference - all or nothing principle}
There are also situations where even strong type inference is not enough.
Figure \ref{img29:usecase3} shows a situation where the \texttt{log} method is parametrized by two type parameters that are obtained in the parameter types and hence inferable by the compiler. 
However, the \texttt{log} method call still has to specify type arguments because the \texttt{null} argument doesn’t have concrete type information. 
In this case, the user always has to specify the second type argument, but the compiler can infer the first type argument. 
The thesis refers to this problem as \textit{all or nothing} principle, which regards the obligation to specify all type arguments or none of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<Message, Appendix>(new Message(...), null);
...
void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Uninferable type argument.}
\label{img29:usecase3}
\end{figure}
\par
\info{Breaking changes - Possible improvement of method type inference}
The first and the second weaknesses motivate us to extend the method type inference in order to consider a wider context for obtaining type information for the type arguments. 
This potential improvement is a problem for the compiler's back compatibility which was mentioned in the C\# discussion \cite{online:breakingChange}. 
New compiler versions should be back-compatible so that a new version does not change the behavior of the code compiled by the older version.
\par
\info{Breaking changes - target-typing}
Figure \ref{img30:breakingChange1} shows the breaking change when method type inference starts to consider target types. 
Before the improvement, the \texttt{M} method call is resolved to the non-generic version of this method because type inference can’t infer the \texttt{T} type argument. 
After the improvement, the type inference infers \texttt{T} to be the \texttt{int} type, which is more specific to the type of \texttt{1} argument than the \texttt{long} type. 
So now, the \texttt{M} method call refers to the generic version of this method and executes different code without any warning or error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
int name = M(1);
...
T M<T>(int p1) {...}
int M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Target-typed inference.}
\label{img30:breakingChange1}
\end{figure}
\par
\info{Breaking changes - Constraints-based inference}
Figure \ref{img31:breakingChange2} shows a similar situation when the method type inference starts to consider type parameter constraints. 
Before the improvement, the \texttt{M} method call refers to the non-generic version of the method since the type inference can’t infer the type argument of a generic version. 
After the improvement, the generic version is inferred to have the \texttt{int} type argument and becomes to be more suitable for the overload resolution. 
So, the code behavior changed again because of compiling it with a different compiler's version.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
M(1);
...
void M<T>(int p1) where T : List<int> {...}
void M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Constraints-based inference.}
\label{img31:breakingChange2}
\end{figure}
\par
\info{Possible method type inference improvement doesn't solve the third weakness}
Besides the breaking change, the potential method type inference improvement to use a bigger context still doesn’t solve our third example demonstrating a type parameter, which doesn’t appear in parameter types, return type, and the type parameters’ constraints. 
These obstacles give the reason for introducing a way to hint just ambiguous type arguments to the compiler.
\par
\info{Partial type inference - reduces the first and second weakness}
Partial type inference can reduce the first two weaknesses. 
Type arguments, which the method type inference can’t infer, can be hinted in order to avoid specifying the whole type argument list. 
Let’s now ignore why the underscore character is used and how inferred type variables are determined in the following example. 
The reasons behind that will be mentioned later.
Figure \ref{img32:sol1} shows the usage of partial type inference applied in the second presented example regarding method type inference weaknesses. 
Although the first type argument of the \texttt{Test} method call must still be provided, the second argument is omitted by using the underscore character to determine an inferred type argument. 
The reduction of the first weakness is to isolate the insufficient type inference to type arguments that are directly influenced by it and infer the rest.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
test<TestCaseDefault<MyData>, _>(new MyData());

void test<T, U>(U data) where T : TestCaseDefault<U> {...}
\end{lstlisting}
\caption{Partial type inference: Reducing method type inference weakness.}
\label{img32:sol1}
\end{figure}
\par
\info{Breaking changes - solves the third weakness}
The third motivation example confirms that partial type inference is not just a fix for missing type inference features but is needed when type arguments can’t be inferred at all. 
Figure \ref{img33:sol2} demonstrates a usage of partial type inference where it omits the first type argument since it can be deduced from the first argument type and specifies the ambiguous type that can’t be deduced.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<_, Appendix>(new Message(...), null);

void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Partial type inference: Solving the \textit{all or nothing} problem.}
\label{img33:sol2}
\end{figure}
\par
\info{Constructor type inference - next motivation and improvement}
Partial type inference doesn’t regard only method type inference. 
It can also be introduced in other places. One of the places that seems to be good for that is object creation expression. 
Except for the already mentioned \texttt{new()} operator, no other type inference infers type arguments of a construing generic type. The usage of the type inference is limited since the \texttt{new()} operator requires a target type to infer the construing type. 
Figure \ref{img34:wrapper} shows an example of the limitation, where the \texttt{new()} operator can’t be used since the \texttt{IWrapper} target type is not the \texttt{Wrapper<int>} construing type. 
Hence, the user has to specify the whole type with the \texttt{int} type argument, despite the fact that it could be inferred using method type inference.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<int>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{C\# wrapper class.}
\label{img34:wrapper}
\end{figure}
\par
\info{Constructor type inference - Factory method workaround}
In principle, object creation can be considered a special case of a method call with a side effect(creating the object), which already has method type inference. 
Figure \ref{img35:workaroung} shows a workaround using the \texttt{Create} method, delegating the creation to the constructor call. 
Since the method call type arguments can be inferred, it allows the use of method type inference for inferring type arguments of construing type. 
However, this solution has disadvantages like the necessary boiler-plate and prohibition of using initializers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = Create(1);

static Wrapper<T> Create<T>(T item) => new Wrapper<T>(item);
\end{lstlisting}
\caption{Workaround of constructor type inference.}
\label{img35:workaroung}
\end{figure}
\par
\info{Constructor type inference - strength of method type inference}
A possible solution would be to use method type inference in object creation expression. 
Although this solution would be simple to implement, class type parameters are more likely not to be used in constructor parameter types, which makes the method type inference useless. 
Besides that, options for inferring type arguments of construing type are not limited by not introducing breaking changes since there is no type inference at all. 
So, there is a possibility of introducing an even stronger type inference, which could be one day introduced in the method type inference when there would be a way to make breaking changes in the new compiler version. 
Figure \ref{img36:cti} shows an example of such a generic class whose all type parameters are not used in the constructor.
Because of that, extending the potential method type inference to be used in object creation expressions would be useless since the \texttt{TLogger} can’t be inferred only from parameter types.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class Algorithm<TData, TLogger> where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Use case iusing type paraemter constraints.}
\label{img36:cti}
\end{figure}
\par
\info{Constructor type inference - the first weakness solution}
Introducing improved type inference based on method type inference would solve the mentioned issues. 
Figure \ref{img37:sol1} shows a potential usage of that type inference in the first case regarding the Wrapper class where an underscore is used to represent inferred type argument. 
The inference uses the parameter type of the constructor to infer the \texttt{T} parameter type which is \texttt{int}.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<_>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{Constructor type inference: Wrapper.}
\label{img37:sol1}
\end{figure}
\par
\info{Constructor type inference - better method type inference}
Figure \ref{img38:sol2} shows a potential improvement of the type inference. 
The first statement of initializing the \texttt{alg} variable uses type inference, leveraging \texttt{TLogger}’s constraint to determine its type. 
The second statement demonstrates the possibility of having a nested underscore, which allows to more specify the type argument.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var alg = new Algorithm<_, _>(new MyData());
var algWithSpecialLogger = 
    new Algorithm<_ , SpecialLogger<_>>(new MyData());

class Algorithm<TData, TLogger> 
    where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Constructor type inference: stronger method type inference.}
\label{img38:sol2}
\end{figure}
\par
From now on, thesis calls \textit{constructor type inference} for introducing such a type inference.

\section{Requirements}
\change{Decribe requirements given by use cases}
\change{Describe requirements given by Roslyn}
\change{Describe requirements given by Future improvements}
\change{Describe requirements given by back compatibility}
\change{Describe requirements given by new language feature proposing}

\section{Language feature design}

\change{Discuss mentioned ideas}
\change{Choose suitable subset of them}
\change{Divide it as in the proposal}
\change{Explain why they sucsess the requirements}

\section{Other type inference improvements}

\change{Shared type inference context}
\change{Inferring return value of methods}