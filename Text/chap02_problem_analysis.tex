\chapter{Problem analysis}
\info{Describe the chapter}
The chapter divides the analysis into four sections. 
The first section describes the scope of the improvement based on the mentioned championed issue recommended by \ac{LDT}. 
The second section mentions a concrete motivation which leads us to the proposed improvement. 
The third section determines requirements based on the motivation, requirements given by proposing new language features, and Roslyn implementation internals. 
The fourth section describes the proposed language feature design, which is inspired by C\# language feature ideas mentioned in the previous chapter and validated by the requirements.
The last section mentions type inference improvements, whose implementation and proposal is not in the scope of this text, altought their possible implementation is sketched for being inspiration of future improvements. 

\section{Scope}
\info{Describe why we choose only a small part of the C\# type inference}
The previous chapter indicates that type inference is a complicated process, where even the current C\# method type inference is difficult to understand. 
Hence, the thesis chooses a small part of C\# where it improves and introduces the type inference and would be possible to reason about and implement in the scope of this text. 
The second reason for choosing a minor change is that introducing a completely new type inference in C\# would rather have an experimental result, which would have a smaller chance of getting into production, which is different from the intention of this work. 
However, some more extensive changes in the type inference will also be mentioned to outline possible obstacles to introducing them in the C\#.
\par
\info{Specify the focus on partial type inference}
The thesis focuses on the already-mentioned \textit{partial type inference} proposal, which was recommended by a member of \ac{LDT} and has a chance to be discussed in \ac{LDM} and potentially accepted. 
Analysis of this improvement contains a consideration of existing ideas, their consequences on C\#, and their difficulties in implementing them in Roslyn. 
Additionally, the work describes the relation to the Hindley-Millner formalization to express the strength of the type inference in a formalized way, which can be further used to compare it with other kinds of type inference in different programming languages and which decides the theoretical boundaries of the C\# type inference.

\section{Motivation}
\info{What is partial type inference and why it is useful}
Partial type inference focuses on hinting to the compiler ambiguous type arguments of generic type or method in situations where it can’t deduce them. 
In the context of C\#, the only type inference that infers type arguments is the method type inference mentioned in the previous chapter. 
The weakness of the method type inference is the need to provide hints to the compiler. 
The following three real-world examples demonstrate common issues with method type inference weakness, which the thesis tries to solve.
\par
\info{Weakness of current method type inference - target typing}
The first weakness regards target typing, which was mentioned in the previous chapter. 
Suppose a hypothetical situation when a user queries an item from a database whose column is a point of interest. 
Figure \ref{img27:usecase1} shows an example of code that uses the \texttt{fetch} method defined on a database type. 
The \texttt{data} variable represents data fetched from a database. 
Since a concrete form of data is unknown, the data has the type of \texttt{object} containing an internal representation of fetched data with the columns stored as fields. 
The \texttt{GetField} method enables one to read the variable’s field of the given name with the supposed type given as a type argument. 
Suppose the fetched object contains the ”name” field containing a string value. 
Now, a user wants to store the value in the \texttt{name} variable, which is explicitly typed. 
Even though the return type of the \texttt{GetField} method is known from the variable declaration, which also is the \texttt{TReturn} type argument of the method, the user still has to specify the type argument in the call. 
Generally, this problem consists of all type inferences, which depend on the target type. The target can be an argument of another method call or an assigning field. 
If the method type inference considers the target type, the user will not have to specify the \texttt{string} type argument in the \texttt{GetField} call.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
object data = database.fetch();
string name = data.GetField<string>("name");
...
static class Extensions {
    static 
    TReturn GetField<TReturn>(this object inst, string fieldName) 
    {...}
}
\end{lstlisting}
\caption{Target-typed inference.}
\label{img27:usecase1}
\end{figure}
\par
\info{Weakness of current method type inference - Constraints-based inference}
The second weakness is noticeable in more advanced generic APIs, like testing frameworks, using type constraints containing the type parameters. 
Figure \ref{img28:usecase2} shows a scenario of a simple test framework that defines the \texttt{Test} method parameterized by a type of input data and test case represented as type parameters \texttt{U} and \texttt{V}, respectively. 
The providing type argument representing the test case has to inherit the \texttt{TestCaseBase} base implementation, which is a generic type parametrized by a type of input data. 
This constraint gives type information about the \texttt{T} type parameter, which is related to the type of input data. 
However, the user has to specify type arguments in the \texttt{Test} call since the type inference doesn’t consider this source of type information. 
If the compiler considers the constraint, the type arguments will be inferred, saving the type annotations.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Test<TestCaseBase<MyData>, MyData>(new MyData());
...
void Test<T, U>(U data) where T : TestCaseBase<U> {...}
\end{lstlisting}
\caption{Constraints-based inference.}
\label{img28:usecase2}
\end{figure}
\par
\info{Weakness of current method type inference - all or nothing principle}
There are also situations where even strong type inference is not enough.
Figure \ref{img29:usecase3} shows a situation where the \texttt{log} method is parametrized by two type parameters that are obtained in the parameter types and hence inferable by the compiler. 
However, the \texttt{log} method call still has to specify type arguments because the \texttt{null} argument doesn’t have concrete type information. 
In this case, the user always has to specify the second type argument, but the compiler can infer the first type argument. 
The thesis refers to this problem as \textit{all or nothing} principle, which regards the obligation to specify all type arguments or none of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<Message, Appendix>(new Message(...), null);
...
void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Uninferable type argument.}
\label{img29:usecase3}
\end{figure}
\par
\info{Breaking changes - Possible improvement of method type inference}
The first and the second weaknesses motivate us to extend the method type inference in order to consider a wider context for obtaining type information for the type arguments. 
This potential improvement is a problem for the compiler's back compatibility which was mentioned in the C\# discussion \cite{online:breakingChange}. 
New compiler versions should be back-compatible so that a new version does not change the behavior of the code compiled by the older version.
\par
\info{Breaking changes - target-typing}
Figure \ref{img30:breakingChange1} shows the breaking change when method type inference starts to consider target types. 
Before the improvement, the \texttt{M} method call is resolved to the non-generic version of this method because type inference can’t infer the \texttt{T} type argument. 
After the improvement, the type inference infers \texttt{T} to be the \texttt{int} type, which is more specific to the type of \texttt{1} argument than the \texttt{long} type. 
So now, the \texttt{M} method call refers to the generic version of this method and executes different code without any warning or error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
int name = M(1);
...
T M<T>(int p1) {...}
int M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Target-typed inference.}
\label{img30:breakingChange1}
\end{figure}
\par
\info{Breaking changes - Constraints-based inference}
Figure \ref{img31:breakingChange2} shows a similar situation when the method type inference starts to consider type parameter constraints. 
Before the improvement, the \texttt{M} method call refers to the non-generic version of the method since the type inference can’t infer the type argument of a generic version. 
After the improvement, the generic version is inferred to have the \texttt{int} type argument and becomes to be more suitable for the overload resolution. 
So, the code behavior changed again because of compiling it with a different compiler's version.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
M(1);
...
void M<T>(int p1) where T : List<int> {...}
void M(long p2) {...}
\end{lstlisting}
\caption{Breaking change: Constraints-based inference.}
\label{img31:breakingChange2}
\end{figure}
\par
\info{Possible method type inference improvement doesn't solve the third weakness}
Besides the breaking change, the potential method type inference improvement to use a bigger context still doesn’t solve our third example demonstrating a type parameter, which doesn’t appear in parameter types, return type, and the type parameters’ constraints. 
These obstacles give the reason for introducing a way to hint just ambiguous type arguments to the compiler.
\par
\info{Partial type inference - reduces the first and second weakness}
Partial type inference can reduce the first two weaknesses. 
Type arguments, which the method type inference can’t infer, can be hinted in order to avoid specifying the whole type argument list. 
Let’s now ignore why the underscore character is used and how inferred type variables are determined in the following example. 
The reasons behind that will be mentioned later.
Figure \ref{img32:sol1} shows the usage of partial type inference applied in the second presented example regarding method type inference weaknesses. 
Although the first type argument of the \texttt{Test} method call must still be provided, the second argument is omitted by using the underscore character to determine an inferred type argument. 
The reduction of the first weakness is to isolate the insufficient type inference to type arguments that are directly influenced by it and infer the rest.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
test<TestCaseDefault<MyData>, _>(new MyData());

void test<T, U>(U data) where T : TestCaseDefault<U> {...}
\end{lstlisting}
\caption{Partial type inference: Reducing method type inference weakness.}
\label{img32:sol1}
\end{figure}
\par
\info{Breaking changes - solves the third weakness}
The third motivation example confirms that partial type inference is not just a fix for missing type inference features but is needed when type arguments can’t be inferred at all. 
Figure \ref{img33:sol2} demonstrates a usage of partial type inference where it omits the first type argument since it can be deduced from the first argument type and specifies the ambiguous type that can’t be deduced.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
log<_, Appendix>(new Message(...), null);

void log<T, U>(T message, U appendix) {...}
\end{lstlisting}
\caption{Partial type inference: Solving the \textit{all or nothing} problem.}
\label{img33:sol2}
\end{figure}
\par
\info{Constructor type inference - next motivation and improvement}
Partial type inference doesn’t regard only method type inference. 
It can also be introduced in other places. One of the places that seems to be good for that is object creation expression. 
Except for the already mentioned \texttt{new()} operator, no other type inference infers type arguments of a construing generic type. The usage of the type inference is limited since the \texttt{new()} operator requires a target type to infer the construing type. 
Figure \ref{img34:wrapper} shows an example of the limitation, where the \texttt{new()} operator can’t be used since the \texttt{IWrapper} target type is not the \texttt{Wrapper<int>} construing type. 
Hence, the user has to specify the whole type with the \texttt{int} type argument, despite the fact that it could be inferred using method type inference.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<int>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{C\# wrapper class.}
\label{img34:wrapper}
\end{figure}
\par
\info{Constructor type inference - Factory method workaround}
In principle, object creation can be considered a special case of a method call with a side effect(creating the object), which already has method type inference. 
Figure \ref{img35:workaroung} shows a workaround using the \texttt{Create} method, delegating the creation to the constructor call. 
Since the method call type arguments can be inferred, it allows the use of method type inference for inferring type arguments of construing type. 
However, this solution has disadvantages like the necessary boiler-plate and prohibition of using initializers.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = Create(1);

static Wrapper<T> Create<T>(T item) => new Wrapper<T>(item);
\end{lstlisting}
\caption{Workaround of constructor type inference.}
\label{img35:workaroung}
\end{figure}
\par
\info{Constructor type inference - strength of method type inference}
A possible solution would be to use method type inference in object creation expression. 
Although this solution would be simple to implement, class type parameters are more likely not to be used in constructor parameter types, which makes the method type inference useless. 
Besides that, options for inferring type arguments of construing type are not limited by not introducing breaking changes since there is no type inference at all. 
So, there is a possibility of introducing an even stronger type inference, which could be one day introduced in the method type inference when there would be a way to make breaking changes in the new compiler version. 
Figure \ref{img36:cti} shows an example of such a generic class whose all type parameters are not used in the constructor.
Because of that, extending the potential method type inference to be used in object creation expressions would be useless since the \texttt{TLogger} can’t be inferred only from parameter types.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class Algorithm<TData, TLogger> where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Use case iusing type paraemter constraints.}
\label{img36:cti}
\end{figure}
\par
\info{Constructor type inference - the first weakness solution}
Introducing improved type inference based on method type inference would solve the mentioned issues. 
Figure \ref{img37:sol1} shows a potential usage of that type inference in the first case regarding the Wrapper class where an underscore is used to represent inferred type argument. 
The inference uses the parameter type of the constructor to infer the \texttt{T} parameter type which is \texttt{int}.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
IWrapper a = new Wrapper<_>(1);

class Wrapper<T> : IWrapper { public Wrapper(T item) {...} }
\end{lstlisting}
\caption{Constructor type inference: Wrapper.}
\label{img37:sol1}
\end{figure}
\par
\info{Constructor type inference - better method type inference}
Figure \ref{img38:sol2} shows a potential improvement of the type inference. 
The first statement of initializing the \texttt{alg} variable uses type inference, leveraging \texttt{TLogger}’s constraint to determine its type. 
The second statement demonstrates the possibility of having a nested underscore, which allows to more specify the type argument.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
var alg = new Algorithm<_, _>(new MyData());
var algWithSpecialLogger = 
    new Algorithm<_ , SpecialLogger<_>>(new MyData());

class Algorithm<TData, TLogger> 
    where TLogger : Logger<TData> 
{ public Algorithm(TData data) { ... }}
\end{lstlisting}
\caption{Constructor type inference: stronger method type inference.}
\label{img38:sol2}
\end{figure}
\par
From now on, thesis calls \textit{constructor type inference} for introducing such a type inference.

\section{Requirements}

\info{intro}
This section mentions requirements that have to be fulfilled by the improvement to be likely discussed by \ac{LDM}.
\par
\info{Describe requirements given by back compatibility}
\textbf{Back compatibility} is one of the most important requirements for new language features. 
The improvement shouldn’t introduce a breaking change. However, this requirement is sometimes too strict for improvements, which would be very beneficial, and its breaking change would appear in cases that seem to be rare in the code. 
These improvements can break back compatibility by providing additional warnings or errors alerting a user of possible code behavior changes.
Figure \ref{img39:brkCh} shows an introduced breaking change when record classes were added into the C\# language. 
Before the change, the \texttt{B} identifier referred to a method without parameters and returned the \texttt{record} type. 
After the change, the \texttt{B} identifier refers to a new record type declaration. 
There is an example where the breaking change can appear when there is a type with the \texttt{record} name. 
These situations are uncommon, and the improvement benefit was big enough to be added to the language. 
The possible breaking change is notified to the user by a compilation error.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
class record {}
class A {
    record B(){...}
}
\end{lstlisting}
\caption{C\# record class breaking change.}
\label{img39:brkCh}
\end{figure}
\par
\info{Decribe requirements given by motivation}
\textbf{Convenience} is a key requirement to make the improvement useful. 
Regarding partial type inference, the improvement should propose a convenient way to skip ambiguous type arguments. 
The way should also be possible to use in different places where skipping type arguments could yield an advantage, like type variable declaration or casting to a different type. 
Constructor type inference should be advanced enough to cover the mentioned examples.
\par
\info{Describe requirements given by Future improvements}
\textbf{Extensibility} would make the improvement open for new features that can be needed in future language versions. 
The improvement should consider possible future improvements and not be a blocker for them.
\par
\info{Describe requirements given by Roslyn}
\textbf{Performance} is a critical section of Roslyn, which is one of the main goals of this project.
The time complexity added by the thesis’s improvement shouldn’t be too big in order to not slow the compilation process.

\section{Language feature design}

\info{Intro}
This section describes the language design of the proposed improvement. 
It discusses existing ideas of the partial type inference and combines them to form the proposed design. 
Then, it adjusts method type inference algorithm to handle partially specified type arguments and introduces constructor type inference, which extends method type inference algorithm.
\par
\info{Discuss mentioned ideas}
The mentioned ideas can be categorized into three groups. 
The first group consists of target-typed inference and type inference based on type constraints, which improve method type inference algorithm. 
The second group consists of default type parameters, generic aliases, named type parameters, using char as inferred type argument, and relocation, which regards partial type inference. 
The third group consists of constructor type inference and type inference of method return type, which introduce type inference in new C# constructs. 
Method return type inference is not in the scope of this work, although it is mentioned in the next section as a future improvement that will be difficult to implement. 
The first group is discussed in relation to constructor type inference, where potentially applied method type inference can be improved without introducing breaking changes. 
The second group is discussed in relation to partial type inference, which is an objective of the championed issue.

\subsection{Partial method type inference}

Discussions regarding partial type inference can be further divided into two groups. 
The first group provides hints in type parameter declarations, which are done by default type parameters. 
Since it has to be done in the declaration, partial type inference wouldn’t work with already existing code without adjusting it.
For this reason, the work excludes the idea.
\par
The second group provides hints through the usage. 
Generic aliases
don’t work for methods, and also, it doesn’t seem to be useful when the inferred type arguments don’t represent some common specialization of generic type.  
An example of the specialization is \texttt{StringDictionary<TValue>} mentioned in the previous chapter.
\par
Named type parameters are excluded since providing that would be an uncommon new feature that has no equivalent in other well-known languages like Java, C++, Kotlin, and Rust. 
We believe it would be confusing to introduce it to the users since it is a controversial change.
\par
Relocation doesn’t solve the problem of specifying all type arguments. 
It just compacts type argument lists into one.
\par
The last discussion regards using char as an inferred type argument, which is a core of the proposed design for the following reasons. 
It is already used in different languages, like a star in Kolin and Java or an underscore in Rust and F\#. 
So, it is more common and intentional than previously mentioned ideas. 
It introduces no or at least minimal syntax changes into the language, which makes the usage simple, and it solves the problem of specifying all type arguments.

\subsubsection{Choosing the syntax}

The choice of the syntax is based on six use cases where the expression of inferred type argument can be used or could be used in the future. 
Table \ref{table2:useCasesChar} shows examples of these usages, which identify necessary syntax requirements.
\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | } 
  \hline
  Generic method call & \texttt{Foo<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Object creation expression & \texttt{new Bar<\{SYNTAX\}>(arg1, arg2,...)}\\
  \hline
  Variable declaration & \texttt{Bar<\{SYNTAX\}> temp = ...}\\
  \hline
  Array type & \texttt{\{SYNTAX\}[]}\\
  \hline
  Inferred type & \texttt{\{SYNTAX\}}\\
  \hline
  Inferred nullable type & \texttt{\{SYNTAX\}?}\\
  \hline
\end{tabular}
\end{center}
\caption{Use cases containing syntax for inferred type argument.}
\label{table2:useCasesChar}
\end{table}
\par
\textbf{Generic method call} use case represents a situation where the syntax is used during a generic method call.
\par
\textbf{Object creation expression} represents the usage in the construction of generic type.
\par
\textbf{Variable declaration} represents the potential usage in the variable type declaration, which is not in the scope of this work. 
However, it is a natural continuation of partial type inference extension where the inferred type arguments are determined by the surrounding context.
\par
\textbf{Array type} has a different syntax of type argument list specifying a type of the contained elements. 
The type of the elements can also be inferred, and the proposed syntax has to offer a convenient way to express an array type with the inferred element type.
\par
\textbf{Inferred type} doesn’t have to be contained only in the type argument list.
The previous chapter presented the \text{var} keyword used in the variable declaration, whose type is determined by the type of initializing value. 
C\# also offers a discard pattern \cite{online:discard} represented by an underscore, which is commonly used as a placeholder for variables that are not intentionally used in the code. 
Since type argument inference relates to that, the syntax should be at least aligned with already existing related syntax. 
The alignment will help the syntax to be naturally used without using language documentation.
\par
\textbf{Inferred nullable type} can be used to specify nullability of the inferred type which will be useful in scenarious where non-nullable and nullable code is mixed together.
\par
There are several syntax that can be used for inferred types. 
The work presents the most relevant syntax that appeared in the mentioned ideas and comments on the advantages and disadvantages for each variant.

\paragraph*{Diamond operator} is represened by a pair of two angle brackets \texttt{<>}.
It is used as an empty type argument list determining that the type name or method name is generic.
\par
Figure \ref{img40:opDi1} demonstrates the usage in generic method calls of \texttt{Foo1} and \texttt{Foo2}. 
The declarations of these methods are not important for the purpose of showing the pros and cons. 
Calling the \texttt{Foo1} method with an empty argument list doesn’t make much sense since method type inference is enabled by default without using angle brackets. 
Calling the \texttt{Foo2} method with nested usage of the diamond operator allows limited partial type inference when the diamond operator is used inside the type argument list. 
The \texttt{Bar<>} type partially hints to the compiler the generic type name without specifying the type arguments. 
However, the usage is problematic when there are multiple generic types with the same name since it can cause ambiguity between them. 
This problem is described in the next example.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<>(arg1, arg2, arg3);
Foo2<Bar<>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Diamond operator - generic method call.}
\label{img40:opDi1}
\end{figure}
\par
Figure \ref{img41:opDi2} shows the usage in object creation expression. 
The first statement containing \texttt{Bar<>} name has the advantage of expressing the will to infer the type’s type arguments, which is necessary in comparison to the previous example since the object creation doesn’t offer type inference. 
If the type inference were potentially turned on by default, it would introduce a breaking change. 
However, there is also a disadvantage of the usage since it doesn’t specify the arity of the generic type. If there were multiple generic types differing in arity, it would complicate the already mentioned overload resolution phase since all constructors from these generic types would have to be considered. The process would be computationally demanding. 
A possible solution would be the following restriction. 
Usually, there is not more than one generic type with the same name. 
So when there is just one type of that name, the diamond operator would be allowed to use it since the name determined one specific generic type. 
In the example, \texttt{Baz<>} would refer to \texttt{Baz<T1, T2>} generic type since there is no other generic type with the same name, causing the ambiguity.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
new Bar<>(...);
new Baz<>(...);

class Bar { ... }
class Bar<T1> { ... }
class Bar<T1, T2> { ... }

class Baz<T1,T2> { ... }
\end{lstlisting}
\caption{Diamond operator - object creation expression.}
\label{img41:opDi2}
\end{figure}
\par
The third example is shown in Figure \ref{img42:opDi3}, where the generic \texttt{Wrapper} class is used to specify the wrapping generic type. 
However, it doesn’t offer to specify any type arguments, which is limiting when the compiler can’t infer all of them.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Wrapper<> temp = ...
\end{lstlisting}
\caption{Diamond operator - variable declaration.}
\label{img42:opDi3}
\end{figure}
\par
Figure \ref{img43:opDi4} shows the operator as an indicator of the inferred element of the array type. 
Since there isn’t a known popular language similar to C\#, which would contain a similar construct, the usage is considered to be unintentional for most of the users.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
<>[] temp = ...
\end{lstlisting}
\caption{Diamond operator - array type.}
\label{img43:opDi4}
\end{figure}
\par
Similar conclusions are made in the last example in Figure \ref{img44:opDi5} where the \texttt{<>} operator has the same functionality as the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
<> temp = ...
\end{lstlisting}
\caption{Diamond operator - inferred type.}
\label{img44:opDi5}
\end{figure}
\par
The \texttt{?} nullable operator can be appended to the diamond operator.
In general, each syntax introducing a placeholder which is not a whitespace is suitable for appending the \texttt{?} operator

\paragraph*{Whitespace separated by commas} is the next proposed syntax, which would allow skipping inferred type arguments and specify just the ambiguous. 
It would also determine the arity of type, which is important for the type name look-up phase of the compiler. 
A natural choice for the separator is commas since it is widely used. 
Another advantage is that this syntax is already used when working with C\# reflaction. 
An example is the following expression \texttt{typeof(Dictionary<,>)}, which returns a class describing the \texttt{Dictionary} type.
\par
Figure \ref{img45:opW1} shows the usage when the \texttt{Foo1} generic method is called by
skipping the first and the last type argument, which is inferred by the compiler. 
However, the syntax seems to be messy when it is used in generic methods with many generic type parameters, as can be seen in the \texttt{Foo2} method call. 
Similar thoughts regard the second and third use case.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
Foo1<, string, List<>, >(arg1, arg2, arg3);
Foo2<,,,int,,>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Whitespace - generic method call.}
\label{img45:opW1}
\end{figure}
\par
The usage with array type seems to be unintentional and would cause changes in the compiler parser. 
Figure \ref{img46:opW4} shows the syntax to express the inferred type of array's element.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
[] temp = ...
Foo<, [], >(arg1, arg2)
\end{lstlisting}
\caption{Whitespace - array type.}
\label{img46:opW4}
\end{figure}
\par
The last use case regarding using the whitespace as an inferred type would probably cause problems with determining declarations of variables. 
Figure \ref{img47:opW5} shows a situation where the compiler can’t determine if it is a variable declaration or a variable assignment. 
Although it could be solved by investigating the surrounding context, we consider that the code comprehension would get worse.
\begin{figure}[h]
\begin{lstlisting}[style=csharp]
temp = ...
\end{lstlisting}
\caption{Whitespace - inferred type.}
\label{img47:opW5}
\end{figure}
\par
Since there is no placeholder which will be prepended to the nullable operator, this option doesn't work well in this scenario.

\paragraph*{Underscores separated by commas} is commonly used in other programming languages like F\# or Haskell to represent inferred type arguments, or as a placeholder for discarding variables that are intentionally not used. 
This is considered as a big advantage. 
A disadvantage is the introduction of breaking change because C\# allows the underscore as a type identifier. 
However, that seems to be rather uncommon in the code. 
It seems to be less messy than the previous syntax when a generic type contains many type parameters, as shown in Figure \ref{img50:opU1}.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
new Bar<_, _, List<_>, _,_>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Underscore - object creation expression.}
\label{img50:opU1}
\end{figure}
\par
The usage with array type also seems to work even if it can still be considered uncommon. 
Figure \ref{img51:opU4} shows the usage where we think that the syntax intentionally expresses the inferred type of array’s elements.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_[] temp = ...
\end{lstlisting}
\caption{Underscore - array type.}
\label{img51:opU4}
\end{figure}
\par
The last use case is shown in Figure \ref{img52:opU5} where it clashes with the already existing \texttt{var} keyword.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
_ temp = ...
\end{lstlisting}
\caption{Underscore - variable declaration.}
\label{img52:opU5}
\end{figure}


\paragraph*{\texttt{var} keywords separated by commas} are another natural option of the syntax. 
The big advantage of the syntax is the already used var keyword in the variable declaration, whose meaning is coherent with inferred type arguments. 
However, it starts to raise the question if it brings the advantage of saving keystrokes. 
Figure \ref{img52:opV1} shows a usage of the syntax, which is considered to be unnecessarily long.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<var, string, List<var>, int>(arg1, arg2, arg3);
\end{lstlisting}
\caption{\texttt{var} - generic method call.}
\label{img52:opV1}
\end{figure}

\paragraph*{Something else separated by commas} doesn't make a lot of sense because it needs to assign new meaning to that character in comparison with an underscore, the \texttt{var} keyword, the \texttt{<>} operator, or \texttt{<,,,>} syntax. 
An asterisk can be considered.
However, it can remind a pointer in the context of unmanaged C\# code.

\paragraph*{Conslusion} The thesis chooses the underscore as a placeholder for inferred
type argument since the meaning of this character is related to the intention. 
It also seems to be the shortest and synoptical way to skip inferred type arguments. 
The possible breaking change is not an obstacle in this situation since a similar decision was made for the \texttt{var} keyword, and the situation where it can occur seems to be rare. 
Problems with the potential future extension where the underscore can represent inferred type in the variable declaration would be prohibited to not mix it with the \texttt{var} keyword. 
Although the diamond operator is not very useful in a generic method call, it makes sense in object creation expression. 
The usage and analysis of that is covered by this work as well.

\subsubsection{Method and typename lookup}

The previous section presented the proposed syntax for skipping inferred type arguments using an underscore as a placeholder. 
This section continues with determining what the expression containing the syntax exactly means.
\par
Since an underscore character is a valid type identifier in C\# and there is
1:1 mapping of inferred type arguments to these placeholders, determining the referred generic method containing the proposed syntax is almost unchanged. 
The change is in overload resolution where if the generic method is \textit{partially inferred}, meaning it contains the syntax, the type inference has to be done to determine the type arguments of that method.
\par
An underscore itself can be a nullable or non-nullable type. 
If the inferred type argument has to be a nullable type, the metioned \texttt{?} operator can be appended to the underscore. 
Figure \ref{img53:null} shows an example of using the nullable operator. 
The call of \texttt{Foo} generic method has three type arguments where the first one is inferred by the compiler and which has to be nullable. 
The second type argument is the \texttt{List} type, containing an inferred nullable type argument as well. 
The third type argument doesn’t require the nullable type, so the inferred type can be either nullable or non-nullable.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_?, List<_?>, _>(arg1, arg2, arg3);
\end{lstlisting}
\caption{Inferring nullable type argument.}
\label{img53:null}
\end{figure}
\par
The type name lookup is also almost unchanged. 
If there is an underscore
referring to inferred type argument, it simply ignores the binding of this identifier.
\par
The underscores contained in the type arguments are threatened in the changed type inference algorithm mentioned in the following section.

\subsubsection{Method type inference algorithm change}

The thesis extends method type inference by introducing a new type variable bound which represents inferred type arguments contained in the type argument list.
Firstly, if a generic method call doesn't contain a type argument list, the method type inference is unchanged.
The change is when the generic method is partially inferred.
Figure \ref{img54:partInf} shows an example of partially inferred method \texttt{Foo} containing two type parameters.
The former algorithm identifies the type arguments as type variables for which it tries to find an unique type.
The algorithm can be extended to represent placeholders for inferred type arguments as type variables too.
Using the example, all three underscores would be represented as three unique type variables besides those representing \texttt{T1} and \texttt{T2} type parameters.
However, this extension has to also be respected by the order of type variables fixing and inferring.
A reason can be seen in \texttt{T2} type variable.
The \texttt{Dictionary<\_, \_>} can be considered as a bound for the type variable which has to be respected.
Although this bound contains another type varaibles which are not yet known.
So the algorithm has to firstly infer the type variables contained in that bound and then to infer the \texttt{T2} type variable.
The second observation for this extension is a way of inferring the bounds.
Since type variable bounds can contain another type variables, it is necessary to propagate relation between the bounds in the time of adding new bounds.
An example of this can be demonstrated using the given Figure \ref{img54:partInf}.
The \texttt{Dictionary<\_, \_>} is a bound of the \texttt{T2} type variable.
The second bound is a type of the \texttt{p2} argument.
This type gives us bounds for type variables contained the former bound which has to be propagated.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp]
Foo<_, Dictionary<_, _>>(arg1, new Dictionary<int, int>());

void Foo<T1, T2>(T1 p1, T2 p2)
\end{lstlisting}
\caption{Partially inferred method call.}
\label{img54:partInf}
\end{figure}
\par
The proposed algorithm uses two new definitions of dependendencies which are given below.
\begin{defn}[Shape dependence]
An unfixed type variable \texttt{$X_i$} \emph{shape-depends directly} on an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} represents \textit{inferred\_type\_argument} and it is contained in shape bound of the type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{shape-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{shape-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{shape-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{shape-depends on} \texttt{$X_e$}. Thus \textit{shape-depends on} is the transitive but not reflexive closure of \textit{shape-depends directly on}.
\end{defn}
\begin{defn}[Type dependence]
An unfixed type variable \texttt{$X_i$} \textit{type-depends directly on} an unfixed type variable \texttt{$X_e$} if \texttt{$X_e$} occurs in any bound of type variable \texttt{$X_i$}.
\texttt{$X_e$} \textit{type-depends on} \texttt{$X_i$} if \texttt{$X_e$} \textit{type-depends directly on} \texttt{$X_i$} or if \texttt{$X_i$} \textit{type-depends directly on} \texttt{$X_v$} and \texttt{$X_v$} \textit{type-depends on} \texttt{$X_e$}. 
Thus \textit{type-depends on} is the transitive but not reflexive closure of \textit{type-depends directly on}.
\end{defn}
\par
The required changed of the algorithm is presented as an algorithm divided into three figures and which is based on the former method type inference.
Figure \ref{img54:mainTypeInference1} shows the beginning, the first, and second phase.
The first step is to identify all type variables which would be an objective of the type inference.
This is done by the \texttt{getAllTypeVariables} function which replaces the undescore placeholders in the provided type arguments (If the type arguments were provided) by new type variables and join them with type variables representing type parameters of the method.
\par
Besides already known three types of bound, the algorithm adds \textit{shape-bound} representing a type argument given in the type argument list.
The reason for a new type of bound is the following.
When an user provides the type argument, the algorithm should exactly infer the same type(not containing any unfixed type variables).
None of the already introduced type bounds didn't offer this feature.
An example of this need is described by a potential scenario when there is the \texttt{IList<\_>} type as a type argument.
When the compiler treats nullability, it wants the hinted type parameter to be non-nullable(not \texttt{IList<\_>?}). 
It can happen, other bounds would infer the nullable version, and although \texttt{IList<\_>} can be converted to \texttt{IList<\_>?}, it is not the user's intention.
However, the exact bound would allow this.
\par
\texttt{FirstPhase} before the initial collecting of bounds from argument list it collects shape bounds from the provided type argument list.
The referring \texttt{InferShapeBound} is described later with the rest of inferring methods.
\par
\texttt{SecondPhase} now respects new added dependencies which forces to infer type variables in the correct order.
If there is no type variables which is indenpendent, the algorithm relax the dependencies to break possible circular dependency which still has a chance to be resolved.
In comparison to the former algorithm, the relaxation still has to respect \textit{shape-depends on} relation.
The reason for that is to prohibit that inferred type would be different from the provided "shape" in the type argument list.
The next condition is that at least one bound can't contain an unfixed type variable.
This requirement is to have at least one candidate which could be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
Input: method call M<$S_1$,...$S_n$>($E_1$,...$E_x$) and 
       its signature $T_e$ M<$X_1$,...,$X_n$>($T_1$ $p_1$,...,$T_x$ $p_x$)
Output: inferred $X_1$,...$X_n$,...$X_{n+l}$
$B_{lower}$ = $B_{upper}$ = $B_{exact}$ = $B_{shape} = $F = []
$TV$ = getAllTypeVariables(X, S)
FirstPhase()
SecondPhase()
fn FirstPhase():
  S.foreach(s -> InferShapeBound(s, T[s.idx]))
  /*Continuation as the former method type inference*/
fn SecondPhase():
  while (true):
    $TV_{indep}$ = $TV$.filter(x $\rightarrow$ 
      F[x.idx] == null && $TV$.any(x $\rightarrow$ 
        dependsOn(x, y) && shapeDependsOn(x, y) 
        && typeDependsOn(x, y)
      )
    )
    $TV_{dep}$ = $TV$.filter(x $\rightarrow$
      F[x.idx] == null && $TV$.any(y $\rightarrow$ 
        (dependsOn(y, x) || shapeDependsOn(y, x) 
          || typeDependsOn(y, x)) 
        && !$TV$.any(t $\rightarrow$ shapeDependsOn(x, t))
        && ($B_{lower}$+$B_{upper}$+$B_{exact}$+$B_{shape}$).any(b $\rightarrow$ 
            !b.containsUnfixedTypeVariable
        )
      )
    )
    /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Phases of new Method Type Inference}
\label{img54:mainTypeInference1}
\end{figure}
\par
Figure \ref{img55:mainTypeInference2} shows adjusted three adjusted inferences adding new bounds and presents a new \texttt{InferShape} inference.
The change is in propagating nested type bounds between type variable bounds.
This is done by the \texttt{Propagate} function which is invoked after a new bound was added.
It iterates over all bounds of the type variable and do additional type inference for each bound containing an unfixed type variable checked by the \texttt{containsUnfixedTypeVariable} property.
This step will ensure that the unfixed type variable will receive a bound which is associate with.
Using mentioned example \ref{img54:partInf}, this phase propagates the \texttt{int} type bounds contained in the \texttt{Dictionary<int, int>} type of provided argument to the underscores representing type variables in the \texttt{Dictionary<\_ ,\_>} type argument.
Since the architecture of the algorithm always adds bounds contained in the left argument of the functions to the right argument of the function, it is needed to the inference for each transposition of the pair.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Propagate(Type U, int typeVariable) {
  setOf($B_{shape}$[typeVariable],
    $B_{lower}$[typeVariable],
    $B_{upper}$[typeVariable],
    $B_{exact}$[typeVariable]
  ).foreach(b $\rightarrow$
    if (b.containsUnfixedTypeVariable) InferHelper(U, b)
    if (U.containsUnfixedTypeVariable) InferHelper(b, U)
  )
}

fn InferExact(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{exact}$[t.idx].contains(U)) {
    $B_{exact}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferLower(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{lower}$[t.idx].contains(U)) {
    $B_{lower}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferUpper(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null) &&
    !$B_{upper}$[t.idx].contains(U)) {
    $B_{upper}$[t.idx].add(U)
    Propagate(U, t.idx)
  }
  /*Continuation as the former method type inference*/
fn InferShape(Type U, Type V):
  if (TypeVariable t = TV.find(x $\rightarrow$ V == x && F[x.idx] == null)) {
    $B_{shape}$[t.idx] = U
    Propagate(U, t.idx)
  }
\end{lstlisting}
\caption{\textit{Exact inference}, \textit{Upper-bound inference}, \textit{Lower-bound inference}, \textit{Shape-bound inference}}
\label{img55:mainTypeInference2}
\end{figure}
\par
Table \ref{table3:InferHelper} shows which inference is called based on the inputs.
For example, if the \texttt{U} represents added lower bound and b is a exact bound, the algorithm calls \texttt{InferUpper} inference based.
Intuation behing the table is to respecting bounds reletation between bounds of a type variable.
So for example, all bounds of lower bounds are lower bounds for exact, upper and shape bounds of that type variable, and are exact bounds for each other.
\begin{table}[h!]
\begin{center}
\begin{tabular}{ | c | c | c | c | c | } 
  \hline
   & Lower & Upper & Exact & Shape\\
  \hline
  Lower & InferExact  &  InferUpper & InferUpper & InferLower \\
  \hline
  Upper & InferLower  &  InferExact & InferLower & InferLower \\
  \hline
  Exact & InferLower  &  InferUpper & InferExact & InferExact \\
  \hline
  Shape & InferLower  &  InferUpper & InferExact & InfeExact \\
  \hline
\end{tabular}
\end{center}
\caption{Matrix of \texttt{InferHelper} function.}
\label{table3:InferHelper}
\end{table}
\par
Figure \ref{img55::mainTypeInference3} shows last part of the changed algorithm, type variable fixation.
The set of candidates is changed to respect shape bound ability to express exact form of the inferred type argument.
So if the type variable contains a shape bound, the candidate list contains only this type and other bounds are used to check if the candidate doesn't contradicts with collected bounds.
There are two notes regarding this step.
If there is a shape bound, it doesn't contain any unfixed type variables because of the condition in the second phase.
Hence it will be a valid type argument.
It can happen, that some bounds will contain unfixed type variables.
In this case, these bounds are removed from the checking and candidates.
\begin{figure}[h!]
\begin{lstlisting}[style=myAlgo, mathescape=true]
fn Fix(TypeVariable x):
  $U_{candidates}$ = 
  if ($B_{shape}$[x.idx] != null)
    setOf($B_{shape}$[x.idx])
  else
    ($B_{lower}$[x.idx] + $B_{upper}$[x.idx] + $B_{exact}$[x.idx]).filter(b $\rightarrow$
        !b.containsUnfixedTypeVariable
    )
  /*Continuation as the former method type inference*/
\end{lstlisting}
\caption{Fixing of type variables}
\label{img55::mainTypeInference3}
\end{figure}
\par
The last observation is ensure that the propagation will end.
Since we doesn't add the same bound multiple times, the cycle can't occur.

\subsection{Partial constructor type inference}

Constructor type inference was mentioned in the discussion \cite{online:CtorTInf}, which is a core of the second part of the improvement.
The design of the partial type inference regarding underscore placeholders will be used again in order to be coherent with method type inference.
Other alternatives like using generic aliases, default type parameters or named type parameters have the similar problems as memntioned in the previous section, so either constructor type inference will not be inspired by them.
However, since the inference is not limited by introducing breaking changes because there is not type inference at all, the type inference can be stronger.
The stronger type inference regards target-typed inference which will be useful because object creation is usually associated with assigning it to a target.
It also employs type inference based on type constrains which will provide a wider context for type inference.
Besides these features, the text mentions two additional features which extend the context of type inference and makes the syntax less boiler-plate, althought are controversial for \ac{LDT}.
For this reason, the features are presented as an voluntary extension which can be removed from the core design.
The first feature regards using type information from initializers which would be valuable when creating collection or objects with object initializer syntax.
The second feature uses the diamond operator to turn on the constructor type inference in cases, when the compiler can surely determine the referring generic type whithout knowladge about the arity. 

\subsubsection*{Syntax}

The syntax is similar to partial method type inference.
Figure \ref{img56:constructorTypeInferenceExample} shows a simple usage where the underscore representes the inferred type argument.
This argument is deduced using a type received from the \texttt{t} variable declarations which determines the \texttt{int} type to be the inferred type argument.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
List<int> t = new List<_>();
\end{lstlisting}
\caption{Syntax of constructor type inference.}
\label{img56:constructorTypeInferenceExample}
\end{figure}
\par
Similar to the partial method type inferece, the \texttt{?} nullability operator is allowed to determine the type nullability.

\subsubsection*{Class lookup}

Class lookup is done in the same way as in partial method type inference.
Binding of the underscore identifier is skipped and represents just a inferred type which has to be resolved during type inference.
C\# allows to define nested classes which causes that the identifier can consists of several subidentifiers seperated by dot and each of them can contain a type argument list.
The improvemenet allows to use underscore placeholders referring to inferred type arguments only in an argument list of the type containing the calling constructor(e.g. the last identifier).
This limitation is shown in Figure \ref{img59:TypeArgList} where the first statement is invalid since it contains inferred type arguments in \texttt{GenericWrapper} identifier which doesn't contain the called costructor.
However, the second statement is valid because type arguemnts are only in \texttt{CreatingClass} identifier which constains the called constructor.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new GenericWrapper<_>.CreatingClass<_>(arg1,...); // Not allowed
new GenericWrapper<int>.CreatingClass<_>(arg1,...); // Allowed
\end{lstlisting}
\caption{Allowed inferred type arguments.}
\label{img59:TypeArgList}
\end{figure}

\subsubsection*{Argument binding}

Mentioned target-typed inference complicates binding of the arguments.
When a target is an assigned variable, or a return statemenent, the type of the target is given by the declaration of the varaible or method's return type.
However, when the target is argument of the other method, the type don't have to be known yet if the method is generic.
Figure \ref{img60:target} shows a scenario, when in the time of binding \texttt{Foo} creation expression the target type is not known because the order of binding is from the methods' arguments to the method call.
Without the target type, the type argument of \texttt{Foo} can't be inferred.
The \texttt{Bar} creation expression should be bound first which would infer the type of the first paramenter which could be used as a terget type of \texttt{Foo} creation expression.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<_>(Foo<_>(), 1);

class Bar<T>{
    public Bar(Foo<T> arg1, T arg2){}
}
class Foo<T>{}
\end{lstlisting}
\caption{Target as an argument.}
\label{img60:target}
\end{figure}
\par
This process was mentioned regarding the target-typed \texttt{new()} operator.
Roslyn solves the operator in the following way.
The operator is bound as unconverted bound element which needs to be converted in the future.
When the right overload of the method is chosen, the Roslyn has to generate necessary conversions of these arguments which doent have identical type as the corresponind parameter.
In that time, the operator is conveted by using already known target type.
Result of the conversion is binding of creation expression which type is the target type and arguments are contained in type operator's argument list.
\par
The improvement is inspired by that.
When there is a object creation expression as an argument and the contructor type inference failed, the similar unconverted bound element is created.
After the overload resolution when the types of parameters are known and the necessary conversion is being created, the object creation expression is tried to be bound again with already known target type.
However, the compiler has to be careful here.
It has to try to bind the object creation expression without a target type only once to prevent exponential time of binding.
\par
Figure \ref{img61:exp} shows a scenario, where if the compiler would not do that, it will cause exponential time of binding the expression.
Since the constructor of the \texttt{Bar} type is overloaded, the overload resolution has to check these two overloads.
Each of this checking includes binding of arguments, type inference and checking of aplicability of bound arguments on the inferred constructor.
Since the binding of arguments contains binding of the similar object creation expression, it will do the same overload resolution containing all overloads of the constructor.
The target type can't be provided here, because the type argument is still unknown.
When the binding of this argument is unsuccesful, the argument will be represented as unconverted bound element and will be bound later after the resolution.
This failure will happen for each overload resolution which wastes time because it does the same computation for multiple time.
After the outer object creation expression is inferred using the type of the second argument, it will convert the inner object creation expression be providing the target type and which will resolve in the valid object creation.
These repeating failing is not a problem of the \texttt{new()} operator since it is cheap to automaticly express is as unvonverted bound expression.
Although, there is an observation which will prevent it.
If the argument can't be binded without target type in checking one overload, it also can't be binded without target type in the other overloads.
So the improvement remembers if the argument containing the object creation expression was already bound without target type and failed. 
If this is true, it automaticly skip the binding and return unconverted bound element which will prevent obvious failure and saves the time.  
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<_>(new Bar<_>(null, null), 1);

class Bar<T>{
    public Bar(Foo<T> arg1, T arg2){}
    public Bar(Foo<T> arg1, List<T> arg2){}
}
\end{lstlisting}
\caption{Potential exponential time of binding.}
\label{img61:exp}
\end{figure}

\subsubsection*{Constructor type inference algorithm}

The previous mentioned algorithm for infering method type arguments is unchanged except collecting new bounds in the first phase of the algorithm.
If target type is provided, an upper bound type inference is made from it to the partial inferred type containing the constructor.
If the inferring type contains \texttt{where} clause containint type parameter constrains, for each of the type constrains which represented either inheritance constrains or interface implementation constrains is performed lower bound type inference from it to the corresponding type parameter.
\par
Figure \ref{img62:ctro} shows an example of constructor type inference, where both of the type arguments of the \texttt{Bar} type are inferred.
The algorithm will contain four type variables. The first two variables represents type arguments and the second two variables represents the underscores.
In the first phase, lower bound type inference is made from the \texttt{IBar<int>} type to the \texttt{Bar<\_,\_>} type which will yield in the \texttt{int} lower bound of the type varible representing the first underscore.
Then, the type constrain of \texttt{T2} type parameters causes another lower bound type inference is made from the \texttt{object} type to the type variable representing \texttt{T2} type parameter.
Shape inferences continues to relate type variables representing underscores with type variables representing type parameters.
Then the fixation is made and it results in \texttt{Bar<int, object>} inferred type.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IBar<int> t = Bar<_, _>();


interface IBar<T>{}

class Bar<T1, T2> : IBar<T1> where T2 : object {}
\end{lstlisting}
\caption{Example of type inferences.}
\label{img62:ctro}
\end{figure}

\subsubsection*{Initiliazers extension}

Initializers can be part of the creating expression which allows us to use it as an another source of type information.
As thesis mentions in the previous chapter, initializers are a syntax sugar.
In the case of object initializer, it represents a field assignment.
If the field declaration contains a type parameter, it can be used to deduce the type parameter.
Figure \ref{img58:initializer} shows an example of initializer, when the \texttt{Bar}'s type argument \texttt{int} can be deduced using type information from the initializer.
Since the \texttt{Field} declaration type is the \texttt{T} type parameter and the \texttt{int} value is assigned to that field in the initializer, the compiler can deduce that the type argument is \text{int}.
The improvement allows this inference by performing lower bound type inference for each item in the initializer.
The inference is made from the type of assigning expression to the type of the field's type declaration.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
new Bar<int>{ Field = 1 };

class Bar<T> {
    public T Field;
}
\end{lstlisting}
\caption{Object initializer.}
\label{img58:initializer}
\end{figure}
\par
Similar deduction can be made with array initializers where the element's tpe is inferred.
The improvement allows it by performing lower bound type inference for each item in the initializer.
The inference is made from the type of addigning expression to the inferred type of array's element.
\par
However, collection initializers shown to be a little tricky.
Since it is a syntactical sugar for calling the special \texttt{Add} method for each elemenent, the method can be overloaded.
The previous section regarding Hindley-Millner type inference mentions that overloading can cause an exponention time of the type inference computation because it has to reason about each overload seperatedly with the rest of the inferred bounds.
To prevent slow compilation because of this issue, the improvement allow to use the information for the intializers in the case where the \texttt{Add} method is not overloaded.
This limitation seems to be reasonable since a lot of collections from the standard library don't overload the method.
When there is no overload, the issue with time disappears.
When the condition above is true, the first phase additionally does the lower bound inference for each item in the initializer.
The inference is made from the type of the expression to the type of method paramenter.
\par
The last initializer regards indexers.
Since indexers can be consider as a special case of methods which can be overloaded as well, the same process is made.

\subsubsection*{Diamond operator extension}

Sinnce constructor type inference is invoked when the creating type contains inferred type arguments in its type argument list, it can felt like a boiler plate when all type arguments are infereble.
Figure \ref{img57:diamondExample} shows an example of creating the \texttt{Dictionary} generic type whose all type arguments can be inferred using the target type.
Althought C\# allows to define generic type with the same name and different arity, it is not very common.
The stanard library doesn't contain another type \texttt{Dictionary} with different arity, so specifying the arity in the example is redundant in this case.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IDictionary<int, string> t = new Dictionary<_,_>();
\end{lstlisting}
\caption{Reduncant specification of arity.}
\label{img57:diamondExample}
\end{figure}
\par
For these use cases, where the compiler can confidently choose a generic type without looking at the arity, the diamond operator can be used to turn on the type inference. 
Figure \ref{img58:diamondExample2} shows the usage of diamond operator with the \texttt{Dictionary} type.
Assuming that in the rest of the program there is no other definition of \texttt{Dictionary} type with diferrent arity, the compiler can assume that the referring type is the \texttt{Dictionary} type from the standard library. 
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
IDictionary<int, string> t = new Dictionary<>();
\end{lstlisting}
\caption{Diamond operator.}
\label{img58:diamondExample2}
\end{figure}

\subsection{Partial time inferece during dynamic member invocation}

The previous chapter mentioned that despite of the dynamic binding, the compiler is still able to do some checking of expresion containing the dynamic value.
The compiler checks two relevant expressions containing the dynamic value as an argument.
It is a method invocation which is static or receiver is not a dynamic value and object creation expression.
For each candidate of this kind, a modified parameter list and argument list is created to be checked.
If there is no candidate for which the test suceeded, an compile-time error occurs.
\par
Modified parameter list is created in the following way.
If the candidate is a generic method and type arguments were provided, it substitutes them in the parameter list.
Then all parameters that includes a type parameter are elided with corresponging arguments.
The resulting set of parameters and arguments are checked.
\par
The improvement adjusts the modified parameter list of partially inferred method by substituting only these type arguments, which doesn't contain any inferred type arguments.
The same process is made in object creation expression where the substitution is made on the type containing the constructor condidate.
\par
For practically reasons, it alse annonce a warning about using partial inference in late-bining which does't support it since it is handle by runtime.
However, there are situation, where the runtime is able to infer type arguments even without partially hiniting.
Figure \ref{img63:dinamic} shows an example where the \texttt{Foo} method is inferred by runtime because inferred type arguments are inferrable in the runtime.
These situations are valid and hence the compiler should just warn about it.
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
dynamic t = ...;
Foo<_, _>(t, 1);

void Foo<T>(T arg1, T arg2) {}
\end{lstlisting}
\caption{Runtime type inference.}
\label{img63:dinamic}
\end{figure}

\section{Other type inference improvements}

Besides the proposed improvement described above, the work touched surrounding areas of type inference during the choose of the improvement.
The chapter gives a couple of thoughts about them since they were investigated as well and can be a future extension of the C\# programming language

\subsection{Shared type inference context}

C\# currently has a local type inference preventing advanced type inferences.
The next big improvement of the type inference would be to provide global type inference using inferring context similar to Rust.
However, since it would bring a breaking change, it would require additional tool which would patch the old code to work in the same way compiled with new type inference.
However, this refactoring can be chalanging, so at least it should warn the user about possible change behavior in each possible change of the behavior.

\subsection{Inferring return value of methods}

The work already mentioned a possibility of inferring return valur of the method which can be beneficial for writing simple method whose name indicates the return value helping a reader to understand the code.
An example of the function can be \texttt{ToString} which indicates that the return value is the \texttt{string} type.
\par
This language feature can be seen in the Kotlin programming language which allows to define a method without a return type if the method is exectly one expression.
The Kotlin language is strongly-typed language  developed by Jetbrains.
The Kotlin's main target is JVM and it's goal is to be an alternative to Java with excelent interoperability between these languages to use them almost interchangably in one project.
Because of that, it has similat type system as Java which is not faw away from C\#.
Figure \ref{img64:kotlin} shows an example of the \texttt{MyClass} definition containing the \texttt{toMyString} method definition.
The signiture consists of the \texttt{fun} keyword, the name, and the equal sign followed by the one expression.
The return type of the method is inferred based on the return value of the expression. 
\begin{figure}[h!]
\begin{lstlisting}[style=csharp, mathescape=true]
class MyClass {
    fun toMyString() = "TEXT"
}
\end{lstlisting}
\caption{Kotlin return type inference.}
\label{img64:kotlin}
\end{figure}
\par
The main obstacle regarding inferred return type in method's signatures is an order of compilation and possible mutlithreaded compilation.
The Roslyn compiler first finds all definitions in the program which allows him to compiler method's seperatdly in different threads.
This advantage is because the method's content consists of only types and methods defined in the program which signatures are already known thanks to the previous phase.
So the compiler knows exact return types of the used functions which allows to do type check.
\par
Kotlin divided the method compilation into two groups as it is describe in the video \cite{online:kotlinCompiler}.
The first group contains methods without a return type which is compiled first in a single thread.
This will allow to obtain all signatures of methods in the program.
Obviously, if these methods are recursions, the compiler can't infer the return type and an error occurs.
The second group contains methods with a return type which can be compiled in multiple threads since all method signatures are already known.
\par
Although this implementation would be possible in the Roslyn as well, it would require big portion of changes.
Instead of that, C\# could allow to infer return in local function which is function defined inside a method body and can be used only inside the method.
There are two benefits of this.
The main architecture of Roslyn compiler doesn't have to be change since the method is compiled by one thread and the local functions can't be used outside.
Local functions are usually tied with the method implementation and the return type is not contained in public API, so a reader shouldn't need to know the return type till the time when he/she wants to explore the inner implementation which gives him/her a context to deduce the return type.



