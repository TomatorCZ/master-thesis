\chapter{Solution}

The solution consists of a proposal describing the language feature given in the previous chapter \ref{sect09:lang} and an implementation of the prototype in a separate Roslyn branch.

\section{Proposal}

The final version of the proposal can be found in the \texttt{attachment} folder as the \texttt{partial-type-inference.md} file. 
The file’s format is a standard Markdown used widely in readme files for its advantage of being able to be read without specialized tools visualizing the formatting.

\subsection{Creation process}

The proposal had three stages of development. 
The first version of the document was created in a personal repository \cite{online:personalRepo}, where it was reviewed by a member of Roslyn's development team. 
The review was in the form of a pull request \cite{online:personalPull} where the member suggested several changes on how to structure the proposal and how to refer to the original C\# standard documentation and pointed out possible improvements that would be beneficial to investigate.
\par
After the revisions were made, the member recommended to post it as a discussion \cite{online:discussion1}, which was the first time when a wider community could comment on the proposal. 
Besides several upvotes received from anonymous readers, another member of Roslyn's development team started to give his recommendations on how to adjust the document. 
The main change of the improvement was to erase most of the examples taken from the tests made together with the prototype and replace them with more references to the original C\# documentation.
\par
The third version of the improvement was published as the next discussion \cite{online:discussion2}, where it received even more emoticons as likes or hearts, which was a good sign of progress. 
At that time, the discussion contained just answers to the questions raised by the member of the Roslyn team, which clarified the intention of the improvement.
\par
After this step, the third stage was made by publishing the proposal as a pull request \cite{online:pull2}. 
This step was done after the recommendation from the team member. 
The pull request was continued by another round of clarifications, recommendations, and revisions from three members of Roslyn's team.
\par
The current stage of the proposal at the time of writing is that the pull
request is still open, waiting for the next requirements from the \ac{LDT}.

\subsection{Content}

The whole document has two styles of describing the feature. 
The first style explains the intention of the improvement and necessary relations, which helps to understand it. 
The second style used in the detailed design section is rather a patch of C\# standard documentation, which enables improvement. 
So, the text doesn’t contain fluent sentences but fragments of the documentation that need to be changed.
\par
The proposal consists of five parts. 
The first part gives a quick overview of the proposed change, summarizing it in a few sentences.
\par
The second part describes the motivation why it should be done. The text
and the used examples are similar to those in section \ref{sect10:mot}.
\par
The third and largest part contains a detailed design of the improvement. 
There is a description of grammar change, where it explains a new underscore contextual keyword in the type argument list. 
It is followed by the change of binding method invocation and object creation expressions. 
This part describes the mentioned core design of the improvement with the changed method type inference algorithm. 
The design ends with extending compile-time checking dynamic member invocation, which is explained in section \ref{sect11:dynamic}.
\par
The fourth part comments on the reason for not doing other alternatives contained in the discussions. 
It also mentions two possible extensions of the improvement using the diamond operator \ref{sect13:ex2} and initializers \ref{sect12:ex1} in the type inference context.
\par
The last part suggests other potential improvements given in the future improvements section \ref{sect14:future}.


\section{Implementation}

The already mentioned proposal will be tested by the implementation described in this section. 
The goal of the implementation is to observe the consequences of the proposed feature in a practical way, which can be tried by C\# communitity. 
The goal will be achieved by contributing to the forked Roslyn project on GitHub, which is public. 
Since the proposal is in the state of probing the benefits, the implementation will be rather a proof of concept than a ready-to-production code.

\subsection{Development environment}

Since the compiler is a complicated program consisting of many parts, the creators provide a guide \cite{online:roslynGuide} describing a common workflow including building the compiler, writting tests and the deployment.
\par
We start with cloning the Roslyn repository \cite{online:roslynRepo} and opening it in an IDE.
There are several IDEs, which can be used.
We recommend Visual Studio 2022 \cite{online:vs} which is used to implement the proposal.
The IDE is chosen since it is recommended by the Roslyn folks and provides helpful static code analysis and a debugger which is almost necessary in cases, when a programmer is not familiar with the code base.
However, hardware requirements for opening the repository are quite high in terms of memory consumption when for a smooth experience with browsing and launching the code it requieres around 20 GB of RAM.
So we recommend Visual Studio Code \cite{online:vsCode} in cases, when the hardware resources are limitted as a compensation for worse code analysis.
\par
However, the IDE is not required for launching or deploying the compiler.
The first thing which is necassary for building is a correct version of .NET SDK specified in \texttt{global.json} placed in the rool project.
We use SDK \texttt{8.0.1} which can be downloaded from Microsoft original websites \cite{online:sdk}.
We also use Windows operating system, although the deployment should be possible on Linux or Mac OS as well.
\par
Since the building for large programs like a compiler can be complicated, the root folder provides three scripts which take care of it.
The \texttt{Restore.cmd} script is run firstly to download required packages.
The \texttt{Build.cmd} srcipt is used to build the compiler and the \texttt{Test.cmd} script is used to run tests of the compiler.
The scripts have multiple options which modificates the workflow.
We will mention few of them which is needed for the implementation.

\subsubsection{Testing}

Launching the tests of compiler is done by a sequence of Windows command console commands shown in Figure \ref{img65:runTests}.
Since the repository contains also an implemention of an C\# extension to Visual Studio, tests are divided into several groups which test indenpendent part of the compiler.
In our case, we use the \texttt{-testCompilerOnly} flag to run basic compiler tests.
The tests will be a base line which has to be passed by the implementaion of the proposal.
The result of \texttt{Build.cmd} command is built compiler placed in the \texttt{roslyn/artifacts} folder.
Tests results are stored in the \texttt{Roslyn/artifacts/TestResults} folder as \texttt{.xml} files and \texttt{.html} files for displaying it in the browser.
\begin{figure}[h]
\begin{lstlisting}
Restore.cmd
Build.cmd
Test.cmd -testCompilerOnly
\end{lstlisting}
\caption{Running C\# compiler tests.}
\label{img65:runTests}
\end{figure}
\par
The results of the tests, when we started the implementation, can be seen in the attachment folder \texttt{/Attachment/TestResults/Initial}, where two tests regarding Visual Basic were not passed.
Since our contribution is the the C\# compiler, we ignore it.

\subsubsection{Deployment}

The standard deployment of a new compiler version is bundling it with a new version of the SDK which would require compiling the SDK from sources.
However, there is a possibility to inject own version of the compiler to already installed SDK.
This option was created to temporary hot fix compiler problems delivered with a SDK.
Since the implemention is a proof of concept, this option will be sufficient to check the main functionality of the proposal directly in user's code.
\par
The injection is done by referencing a special package generated by the \texttt{Build.cmd} script in a project file of a target C\# project using partial type inference.
The nuget cache containg .NET packaged needs to be modified before the package generation.
The nuget cache is usually placed in the \texttt{C://Users/\%user\%/.nuget} folder on Windows, where is required to delete the version of \texttt{Microsoft.CSharp.Net.Compiler.ToolSet} package which will be generated by the \texttt{Build.cmd -publish} command.
The command generates the \texttt{roslyn/artifacts/publish/Shipping} folder containg the \texttt{Microsoft.CSharp.Net.Compiler.ToolSet} package which needs to be referenced.
Additionally to the package reference, the project file has to define a folder containing the package which will be used for restoring the packages in the nuget cache.
The last thing is specifying of a language version which has to be set to \texttt{preview} enabling the partial type inference. 
Figure \ref{img68:csproj} shows a modified project file of demo application which can be found in \texttt{Attachment/Demo} folder.
The \texttt{PropertyGroup} element contains a definition of language version and a folder for package restoration.
The \texttt{ItemGroup} element contains a definition of the package reference injecting the locally built compiler. 
\begin{figure}[h]
\begin{lstlisting}
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>preview</LangVersion>
        <RestoreSources>
      E:\roslyn\artifacts\packages\Debug\Shipping
    </RestoreSources>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference 
      Include="Microsoft.Net.Compilers.Toolset" 
      Version="4.9.0-dev"
    />
  </ItemGroup>
</Project>
\end{lstlisting}
\caption{\texttt{Demo.csproj}}
\label{img68:csproj}
\end{figure}
\par
Then, a common \texttt{dotnet build} command can be used to compile the project using own compiler version instead of the bundled one.
There is an easy way to check the currently used compiler by puting the \texttt{\#error version} pragma anywhere into the compiled code.
Figure \ref{img66:pragma} shows the usage of the pragma in the demo application.
\begin{figure}[h]
\begin{lstlisting}
using System;

#error version

class Program {
...
\end{lstlisting}
\caption{Begining of \texttt{Program.cs}.}
\label{img66:pragma}
\end{figure}
\par
When the project is compiled again, it will raise a compilation error annoncing current version the package which is shown in Figure \ref{img67:output}.
We can see, that the code was compiled by \texttt{4.9.0-dev} compiler version and the langauge version was set to \texttt{preview}. 
\begin{figure}[h]
\begin{lstlisting}
E:\Demo>dotnet build
MSBuild version 17.8.3+195e7f5a3 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
E:\Demo\Program.cs(4,8): error CS1029: 
  #error: 'version' [E:\Demo\Demo.csproj]
E:\Demo\Program.cs(4,8): error CS8304: 
  Compiler version: '4.9.0-dev (<developer build>)'. 
  Language version: preview [E:\Demo\Demo.csproj]

Build FAILED.

E:\Demo\Program.cs(4,8): error CS1029: 
  #error: 'version' [E:\Demo\Demo.csproj]
E:\Demo\Program.cs(4,8): error CS8304: 
  Compiler version: '4.9.0-dev (<developer build>)'. 
  Language version: preview. [E:\Demo\Demo.csproj]
    0 Warning(s)
    2 Error(s)

Time Elapsed 00:00:09.19
\end{lstlisting}
\caption{Output of building \texttt{Demo.csproj}}
\label{img67:output}
\end{figure}

\subsection{Repository overview}

Roslyn's repository contains several projects besides C\# compiler like Visual Basic compiler or Visual Studio extension.
Figure \ref{img68:roslynFolder} shows relevant files and folders of the \texttt{roslyn} directory, which are adjusted or used by the implementation.
The root directory contains already mentioned helper scripts for building and deploying the compiler, the \texttt{src} folder containg the code and the \texttt{artifacts} folder generated by a build system.
It also contains the \texttt{Roslyn.sln} solution which can be opened in Visual Studio enabling better user experience during the code browsing.
\par
The artifacts contains the \texttt{TestResults} folder containing already mentioned test reports and the \texttt{bin} folder containing compiled code and packages.
The mentioned package required for injecting the compiled compiler can be found in the nested \texttt{Shipping} folder.
\par
There are three important folders nested in the \texttt{src} folder.
The \texttt{Test} folder contains compiler tests which can be run by using the \texttt{testCompilerOnly} flag.
The \texttt{Core} folder contains a common code used by Visual Basic and C\# compiler.
It provides public API used to compile and analyse code.
The last \texttt{CSharp/Portable} folder contains sources of C\# compiler which is modified by proposal's implementation.
\par
Desribing all parts of C\# compiler sources is out of the of this work since it is extensive program and most of the parts are not influenced by the implementaion.
So the work mentions only small part of the compiler, which is necessary to understand implementaion internals.
The compiler's source code is divided into multiple folders where the most of changes happend in the \texttt{Binder} folder.
The folder contains logic for binding \ac{AST} to \textit{bound tree} mentioned in the Roslyn section \ref{sect04:roslyn}.
The implemention of type inference algorithm can be found in the \texttt{Semantics/OverloadResolution} folder together with the whole mechanism for overload resolution of methods and contructors.
The \texttt{BoundTree} folder contains definition of automaticly generated nodes representing \textit{bound tree}.
The \texttt{Errors} folder contains definitions of all C\# errors and a list of features which can be disabled and which contains an item for enabling partial type inference.
The \texttt{FlowAnalysis} contains several control flow analyzers like nullability analyzer checking the nullability state of variables.
The \texttt{Generated} folder contains a generated nodes of \textit{bound tree} and the \texttt{Symbols} folder contains nodes of \ac{AST} tree.
\begin{figure}[h]
\begin{lstlisting}
+roslyn
  +src
    +Compilers
      +Core
      +CSharp
       +Portable
         +Binder
           +Semantics
             +Conversions
             +OverloadResolution
        +BoundTree
        +Errors
        +FlowAnalysis
        +Generated
        +Symbols
          +Source
      +Test
  +artifacts
    +bin
    +packages/Debug
      +Shipping
    +TestResults
  -global.json
  -Roslyn.sln
  -Build.cmd
  -Restore.cmd
  -Test.cmd
\end{lstlisting}
\caption{Simplified view of \texttt{roslyn} directory content.}
\label{img68:roslynFolder}
\end{figure}

\subsection{Test suite}

Roslyn tests use xUnit framework \cite{online:xUnit} providing wide API for testing application functionalities in various scenarious.
We used this framework for our own tests in the \texttt{PartialTypeInferenceTests.cs} file.
Additional helper method \texttt{TestCallSites} was made to save repeating code which initializes the compilation, compiles the provided source code as a string and verifies diagnostics representing compiler warnings and errors.
Since we are interested in information regarding inferenced type arguments, the source code is augmented by comments representing asserts which have the augmented symbols hold.
\par
Figure \ref{img69:test} shows an example of a test case which tests a scenario where an inferred type argument syntax hides a typename having \texttt{\_} identifier.
We can see that the \texttt{new F1<\_>(1)} expression is tested by the following comment describing the desired resolved call.
The second argument of the \texttt{TestCallSites} defines which symbols we assert.
In this case, all object creation expressions are asserted.
The last argument describes expected dieagnostics which should compiler announce.
This example requires a warning regarding notifying an user about possible conflicting class name with the \texttt{\_} contextual keyword.
\begin{figure}[h]
\begin{lstlisting}[style=csharp, showstringspaces=false]
[Fact]
public void PartialConstructorTypeInference_UnderscoreClass()
{
  TestCallSites("""
class P
{
  static void M() 
  {
    new F1<_>(1); //-P.F1<int>..ctor(int)
  }

  class F1<T> { public F1(T p) {} }
}

class _ {}
""",
    Symbols.ObjectCreation,
    ImmutableArray.Create(
      Diagnostic(ErrorCode.WRN_UnderscoreNamedDisallowed, "_")
        .WithLocation(11, 7)
    )
  );
}
\end{lstlisting}
\caption{Example of a test.}
\label{img69:test}
\end{figure}

\subsection{Parsing inferred type arguments}

\change{Describe change in parsing}

\subsection{TypeInferrer}

\change{Describe rewritten type inferrer}

\subsection{Binding partial-inferred method}

\change{Describe the binding}

\subsection{Binding partial-inferred object construction}

\change{Describe the binding}

\subsection{Nullable walker}

\change{Decribe nullable walker}